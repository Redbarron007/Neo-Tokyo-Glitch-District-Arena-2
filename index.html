<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo Tokyo: Glitch District Arena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 15px;
        }

        .app {
            width: 100%;
            max-width: 1300px;
            background: rgba(10, 10, 30, 0.95);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        /* Scanline overlay */
        .app::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,255,255,0.03) 0px, transparent 2px, transparent 4px);
            pointer-events: none;
            z-index: 100;
        }

        /* ===== HEADER ===== */
        .header {
            background: rgba(0,0,0,0.8);
            border-bottom: 2px solid #ff00ff;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .header .title {
            font-size: 22px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .header .run-info {
            font-size: 16px;
            color: #00ffff;
        }
        .music-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 15px;
            color: #888;
        }
        .music-toggle input { cursor: pointer; }

        /* ===== SCREENS ===== */
        .screen { display: none; }
        .screen.active { display: block; }

        /* ===== CHARACTER SELECT ===== */
        .select-screen { padding: 20px; }

        /* ===== TAB NAV ===== */
        .tab-nav {
            display: flex;
            border-bottom: 2px solid #ff00ff;
            background: rgba(0,0,0,0.5);
        }
        .tab-btn {
            padding: 12px 28px;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-right: 1px solid #333;
            background: transparent;
            color: #666;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .tab-btn:hover { color: #00ffff; background: rgba(0,255,255,0.05); }
        .tab-btn.active {
            color: #ff00ff;
            background: rgba(255,0,255,0.1);
            border-bottom: 2px solid #ff00ff;
            margin-bottom: -2px;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        /* ===== HOW TO PLAY ===== */
        .howtoplay { padding: 25px; max-height: 680px; overflow-y: auto; }
        .howtoplay h3 {
            color: #ff00ff;
            font-size: 20px;
            margin: 20px 0 8px;
            text-shadow: 0 0 10px #ff00ff;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .howtoplay h3:first-child { margin-top: 0; }
        .howtoplay p {
            color: #ccc;
            font-size: 15px;
            line-height: 1.7;
            margin-bottom: 8px;
        }
        .howtoplay .highlight { color: #00ffff; font-weight: bold; }
        .howtoplay .warn { color: #ff6600; font-weight: bold; }
        .howtoplay .danger { color: #ff0000; font-weight: bold; }
        .howtoplay .good { color: #44ff44; font-weight: bold; }
        .stance-triangle {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .stance-box {
            padding: 12px 20px;
            border: 2px solid;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            min-width: 110px;
        }
        .stance-box.rush { border-color: #ff4444; color: #ff4444; }
        .stance-box.counter { border-color: #4488ff; color: #4488ff; }
        .stance-box.zone { border-color: #44ff44; color: #44ff44; }
        .stance-arrow { color: #ff00ff; font-size: 22px; font-weight: bold; }
        .archetype-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
            margin: 12px 0;
        }
        .archetype-card {
            background: rgba(0,255,255,0.04);
            border: 1px solid #333;
            padding: 14px;
        }
        .archetype-card .arch-name {
            color: #ff00ff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .archetype-card .arch-weapon {
            color: #ffaa00;
            font-size: 13px;
            margin-bottom: 6px;
        }
        .archetype-card p {
            color: #aaa;
            font-size: 14px;
            line-height: 1.5;
            margin: 0;
        }
        .tip-box {
            background: rgba(255,170,0,0.08);
            border: 1px solid #ff6600;
            padding: 12px 16px;
            margin: 12px 0;
            color: #ffaa00;
            font-size: 14px;
            line-height: 1.6;
        }
        .select-screen h2 {
            text-align: center;
            color: #ff00ff;
            font-size: 30px;
            margin-bottom: 5px;
            text-shadow: 0 0 15px #ff00ff;
        }
        .select-subtitle {
            text-align: center;
            color: #888;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .char-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 10px;
            max-height: 580px;
            overflow-y: auto;
            padding: 5px;
        }
        .char-card {
            background: rgba(0,255,255,0.05);
            border: 2px solid #333;
            padding: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            position: relative;
        }
        .char-card:hover {
            border-color: #ff00ff;
            box-shadow: 0 0 15px rgba(255,0,255,0.4);
        }
        .char-card.selected {
            border-color: #ff00ff;
            background: rgba(255,0,255,0.15);
            box-shadow: 0 0 20px rgba(255,0,255,0.6);
        }
        .char-card img {
            width: 100%;
            height: 110px;
            object-fit: contain;
        }
        .char-card .card-name {
            font-size: 12px;
            color: #00ffff;
            margin-top: 3px;
        }
        .char-card .card-stats {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        .char-card .card-weapon {
            font-size: 11px;
            color: #ff00ff;
            margin-top: 1px;
        }

        /* v15: Hard Mode clear star — top-left of card */
        .char-card .hard-clear-star {
            position: absolute;
            top: 4px;
            left: 5px;
            font-size: 13px;
            line-height: 1;
            filter: drop-shadow(0 0 3px rgba(255, 200, 0, 0.9)) drop-shadow(0 0 7px rgba(220, 140, 0, 0.6));
            animation: starGlimmer 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 2;
        }
        @keyframes starGlimmer {
            0%,100% { opacity: 0.85; filter: drop-shadow(0 0 3px rgba(255,200,0,0.9)) drop-shadow(0 0 7px rgba(220,140,0,0.6)); }
            50%     { opacity: 1;    filter: drop-shadow(0 0 5px rgba(255,220,0,1.0)) drop-shadow(0 0 12px rgba(255,180,0,0.8)); }
        }

        /* ===== MAGNIFIER TOOLTIP ===== */
        .char-tooltip {
            display: none;
            position: fixed;
            z-index: 9999;
            background: rgba(5, 5, 20, 0.98);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.7), inset 0 0 20px rgba(0, 255, 255, 0.05);
            padding: 16px;
            width: 260px;
            pointer-events: none;
        }
        .char-tooltip.visible {
            display: block;
        }
        .char-tooltip img {
            width: 100%;
            height: 180px;
            object-fit: contain;
            display: block;
            margin-bottom: 10px;
            image-rendering: pixelated;
        }
        .char-tooltip .tt-name {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 4px;
            text-shadow: 0 0 8px #00ffff;
        }
        .char-tooltip .tt-archetype {
            font-size: 14px;
            color: #ff00ff;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .char-tooltip .tt-weapon {
            font-size: 13px;
            color: #ffaa00;
            margin-bottom: 10px;
        }
        .char-tooltip .tt-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-bottom: 10px;
        }
        .char-tooltip .tt-stat {
            font-size: 13px;
            color: #00ffff;
            background: rgba(0,255,255,0.08);
            padding: 4px 8px;
            border: 1px solid rgba(0,255,255,0.2);
        }
        .char-tooltip .tt-stat span {
            color: #fff;
            font-weight: bold;
        }
        .char-tooltip .tt-desc {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        .char-tooltip .tt-hp-bar {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            margin-top: 4px;
        }
        .char-tooltip .tt-hp-pip {
            width: 14px;
            height: 12px;
            background: #00ff66;
            border: 1px solid #009933;
        }

        .select-info {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid #333;
            background: rgba(0,0,0,0.4);
            min-height: 80px;
        }
        .select-info h3 {
            color: #ff00ff;
            font-size: 18px;
            margin-bottom: 5px;
        }
        .select-info .stat-line {
            font-size: 15px;
            color: #00ffff;
            margin: 2px 0;
        }
        .select-info .archetype-desc {
            font-size: 14px;
            color: #888;
            margin-top: 5px;
        }

        .btn {
            padding: 14px 35px;
            font-family: inherit;
            font-size: 18px;
            border: 2px solid #ff00ff;
            background: rgba(255,0,255,0.2);
            color: #ff00ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
        }
        .btn:hover:not(:disabled) {
            background: rgba(255,0,255,0.4);
            box-shadow: 0 0 15px rgba(255,0,255,0.5);
        }
        .btn:disabled {
            opacity: 0.3;
            cursor: default;
        }
        .btn-row {
            text-align: center;
            margin-top: 15px;
        }

        /* ===== ARENA ===== */
        .arena-screen { position: relative; }
        .arena-bg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("https://raw.githubusercontent.com/Redbarron007/Neo-Tokyo-Glitch-District-Arena/main/arena_2.jpg");
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .arena-bg img {
            width: 100%; height: 100%;
            object-fit: cover;
        }

        .arena-content {
            position: relative;
            height: 620px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* HUD Bar */
        .hud {
            display: flex;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(0,0,0,0.7);
            border-bottom: 1px solid #333;
            z-index: 10;
            flex-shrink: 0;
        }
        .hud-side {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 240px;
        }
        .hud-side.right { text-align: right; align-items: flex-end; }
        .hud-name {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
        }
        .hud-name.enemy { color: #ff4444; }
        .hud-archetype {
            font-size: 13px;
            color: #888;
        }
        .hud-stats {
            display: flex;
            gap: 12px;
            font-size: 14px;
        }
        .hud-side.right .hud-stats { justify-content: flex-end; }
        .hp-bar {
            display: flex;
            gap: 2px;
        }
        .hp-pip {
            width: 16px;
            height: 14px;
            background: #00ff66;
            border: 1px solid #009933;
        }
        .hp-pip.empty {
            background: #330000;
            border-color: #660000;
        }
        .hp-pip.enemy { background: #ff4444; border-color: #cc0000; }
        .hp-pip.enemy.empty { background: #330000; border-color: #660000; }
        .stability-bar {
            display: flex;
            gap: 2px;
        }
        .stab-pip {
            width: 12px;
            height: 12px;
            background: #ffaa00;
            border: 1px solid #cc8800;
        }
        .stab-pip.empty {
            background: #1a1a00;
            border-color: #333300;
        }
        .stat-label {
            color: #888;
            font-size: 13px;
        }
        .hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .clash-num {
            font-size: 26px;
            color: #ff00ff;
            font-weight: bold;
        }
        .fight-label {
            font-size: 13px;
            color: #666;
        }

        /* Fighters area */
        .fighters-area {
            flex: 1;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding: 0 40px 0;
            min-height: 0;
            overflow: visible;
        }
        .fighter-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .fighter-sprite {
            width: 190px;
            height: 270px;
            position: relative;
            overflow: visible;
        }
        .fighter-sprite img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .fighter-sprite.right img {
            transform: translateX(-50%) scaleX(-1);
            bottom: 0;
        }
        /* v12: Final boss (id 99) — faces correct direction (no flip) and 1.8x larger */
        .fighter-sprite.right.final-boss-sprite img {
            transform: translateX(-50%) scaleX(1);   /* cancel mirror flip */
            transform-origin: center bottom;
            width: 180%;                              /* 1.8x the container width */
            max-width: none;                          /* allow overflow beyond container */
            max-height: none;
        }
        .fighter-sprite.shake {
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        .fighter-sprite .dmg-popup {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000, 2px 2px 0 #000;
            animation: dmgFloat 1s ease-out forwards;
            z-index: 20;
        }
        @keyframes dmgFloat {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-40px); }
        }

        /* Status badges */
        .status-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 12px;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
            z-index: 15;
        }
        .status-badge.overheat {
            background: #ff6600;
            color: #fff;
        }
        .status-badge.meltdown {
            background: #ff0000;
            color: #fff;
            animation: pulse 0.5s infinite;
        }
        .status-badge.danger {
            background: #ffaa00;
            color: #000;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stance selection */
        .stance-panel {
            background: rgba(0,0,0,0.85);
            border-top: 2px solid #ff00ff;
            padding: 8px 15px;
            z-index: 10;
            height: 75px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .stance-prompt {
            text-align: center;
            font-size: 16px;
            color: #888;
            margin-bottom: 8px;
        }
        .stance-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        .stance-btn {
            padding: 14px 30px;
            font-family: inherit;
            font-size: 19px;
            font-weight: bold;
            border: 2px solid #444;
            background: rgba(0,0,0,0.6);
            color: #00ffff;
            cursor: pointer;
            transition: all 0.15s;
            min-width: 140px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .stance-btn:hover {
            border-color: #ff00ff;
            box-shadow: 0 0 15px rgba(255,0,255,0.4);
            color: #ff00ff;
        }
        .stance-btn.rush { border-color: #ff4444; color: #ff4444; }
        .stance-btn.rush:hover { background: rgba(255,68,68,0.2); box-shadow: 0 0 15px rgba(255,68,68,0.4); }
        .stance-btn.counter { border-color: #4488ff; color: #4488ff; }
        .stance-btn.counter:hover { background: rgba(68,136,255,0.2); box-shadow: 0 0 15px rgba(68,136,255,0.4); }
        .stance-btn.zone { border-color: #44ff44; color: #44ff44; }
        .stance-btn.zone:hover { background: rgba(68,255,68,0.2); box-shadow: 0 0 15px rgba(68,255,68,0.4); }
        .stance-btn:disabled { opacity: 0.3; cursor: default; }

        /* Clash log */
        .clash-log {
            background: rgba(0,0,0,0.7);
            border-top: 1px solid #333;
            padding: 6px 20px;
            height: 80px;
            overflow-y: auto;
            font-size: 13px;
            z-index: 10;
            flex-shrink: 0;
        }
        .log-entry {
            padding: 2px 0;
            color: #888;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .log-entry.advantage { color: #44ff44; }
        .log-entry.disadvantage { color: #ff4444; }
        .log-entry.overheat-log { color: #ff6600; }
        .log-entry.meltdown-log { color: #ff0000; font-weight: bold; }
        .log-entry.kill { color: #ff00ff; font-weight: bold; }
        .log-entry.boss-intro { color: #00e5ff; font-style: italic; letter-spacing: 0.04em; text-shadow: 0 0 8px rgba(0,229,255,0.6); }

        /* ===== UPGRADE SCREEN ===== */
        .upgrade-screen { padding: 20px; }
        .upgrade-screen h2 {
            text-align: center;
            color: #ff00ff;
            font-size: 28px;
            margin-bottom: 5px;
            text-shadow: 0 0 15px #ff00ff;
        }
        .upgrade-subtitle {
            text-align: center;
            color: #888;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .upgrade-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .upgrade-card {
            background: rgba(0,255,255,0.05);
            border: 2px solid #333;
            padding: 20px;
            cursor: pointer;
            width: 260px;
            transition: all 0.2s;
        }
        .upgrade-card:hover {
            border-color: #ff00ff;
            box-shadow: 0 0 15px rgba(255,0,255,0.4);
        }
        .upgrade-card h3 {
            color: #ff00ff;
            font-size: 18px;
            margin-bottom: 5px;
        }
        .upgrade-card p {
            font-size: 15px;
            color: #00ffff;
        }

        /* ===== GAME OVER ===== */
        .gameover-screen {
            padding: 40px 20px;
            text-align: center;
        }
        .gameover-screen h2 {
            font-size: 32px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            margin-bottom: 10px;
        }
        .gameover-screen .final-stats {
            font-size: 18px;
            color: #00ffff;
            margin: 15px 0;
        }
        .gameover-screen .final-stats div {
            margin: 5px 0;
        }

        /* ===== TITLE SCREEN ===== */
        .title-screen {
            position: relative;
            width: 100%;
            cursor: pointer;
            overflow: hidden;
            background: #000;
            user-select: none;
        }
        .title-screen img.title-img {
            width: 100%;
            display: block;
            image-rendering: pixelated;
        }

        /* Glitch overlay layers */
        .title-glitch-wrap {
            position: relative;
            width: 100%;
        }
        .title-glitch-wrap .glitch-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("https://raw.githubusercontent.com/Redbarron007/Neo-Tokyo-Glitch-District-Arena/main/Title%20Screen.png");
            background-size: 100% 100%;
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: screen;
        }
        .title-glitch-wrap .glitch-layer.r {
            background-position: 2px 0;
            filter: hue-rotate(0deg) saturate(3);
            animation: glitchR 4s infinite;
        }
        .title-glitch-wrap .glitch-layer.b {
            background-position: -2px 0;
            filter: hue-rotate(200deg) saturate(3);
            animation: glitchB 4s infinite 0.1s;
        }

        @keyframes glitchR {
            0%, 87%, 100% { opacity: 0; transform: translate(0,0); }
            88% { opacity: 0.6; transform: translate(4px, 0); clip-path: inset(20% 0 60% 0); }
            89% { opacity: 0; transform: translate(-3px, 2px); }
            90% { opacity: 0.5; transform: translate(6px, -1px); clip-path: inset(55% 0 10% 0); }
            91% { opacity: 0; }
            92% { opacity: 0.4; transform: translate(-4px, 0); clip-path: inset(70% 0 5% 0); }
            93%, 100% { opacity: 0; transform: translate(0,0); }
        }
        @keyframes glitchB {
            0%, 87%, 100% { opacity: 0; transform: translate(0,0); }
            88% { opacity: 0.5; transform: translate(-4px, 1px); clip-path: inset(40% 0 40% 0); }
            89% { opacity: 0; }
            90% { opacity: 0.6; transform: translate(3px, -2px); clip-path: inset(10% 0 70% 0); }
            91% { opacity: 0; transform: translate(-5px, 0); }
            92% { opacity: 0.35; transform: translate(2px, 1px); clip-path: inset(60% 0 15% 0); }
            93%, 100% { opacity: 0; transform: translate(0,0); }
        }

        /* Scanline flicker on glitch */
        @keyframes glitchScan {
            0%, 87%, 93%, 100% { opacity: 0; }
            88%, 90%, 92% { opacity: 1; }
        }
        .title-scan-flicker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px, transparent 3px,
                rgba(0,255,255,0.04) 3px, rgba(0,255,255,0.04) 4px
            );
            pointer-events: none;
            animation: glitchScan 4s infinite;
        }

        /* Horizontal glitch bars that sweep */
        .title-hbar {
            position: absolute;
            left: 0; width: 100%; height: 0;
            background: rgba(0, 255, 255, 0.15);
            pointer-events: none;
            animation: hbarAnim 4s infinite;
        }
        @keyframes hbarAnim {
            0%, 86%, 94%, 100% { height: 0; opacity: 0; }
            87% { top: 25%; height: 8px; opacity: 1; }
            88% { top: 60%; height: 4px; opacity: 0.8; }
            89% { top: 10%; height: 12px; opacity: 0.6; }
            90% { top: 78%; height: 6px; opacity: 0.9; }
            91% { top: 45%; height: 3px; opacity: 0.5; }
            92% { top: 90%; height: 8px; opacity: 0.7; }
            93% { height: 0; opacity: 0; }
        }

        /* Click to play overlay */
        .title-cta {
            position: absolute;
            bottom: 7%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Courier New', monospace;
            font-size: 26px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            letter-spacing: 4px;
            text-transform: uppercase;
            animation: ctaPulse 1.5s ease-in-out infinite;
            white-space: nowrap;
            pointer-events: none;
        }
        @keyframes ctaPulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
            50% { opacity: 0.3; text-shadow: 0 0 5px #00ffff; }
        }

        /* Random pixel noise blocks during glitch */
        .title-noise {
            position: absolute;
            pointer-events: none;
            animation: noiseAnim 4s infinite;
            opacity: 0;
        }
        @keyframes noiseAnim {
            0%, 87%, 93%, 100% { opacity: 0; }
            88% { opacity: 1; left: 15%; top: 30%; width: 120px; height: 8px; background: rgba(255,0,255,0.6); }
            89% { opacity: 1; left: 60%; top: 55%; width: 80px; height: 4px; background: rgba(0,255,255,0.5); }
            90% { opacity: 1; left: 30%; top: 70%; width: 200px; height: 6px; background: rgba(255,255,0,0.4); }
            91% { opacity: 1; left: 70%; top: 20%; width: 60px; height: 10px; background: rgba(255,0,0,0.5); }
            92% { opacity: 0; }
        }

        /* ===== SAVE SYSTEM UI ===== */
        .meta-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 12px 0;
            flex-wrap: wrap;
        }
        .meta-stat-box {
            background: rgba(0,255,255,0.06);
            border: 1px solid #333;
            padding: 10px 18px;
            text-align: center;
            min-width: 90px;
        }
        .meta-stat-box .msb-val {
            font-size: 22px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }
        .meta-stat-box .msb-label {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn-danger {
            border-color: #ff3333;
            background: rgba(255,50,50,0.15);
            color: #ff3333;
            font-size: 13px;
            padding: 8px 20px;
        }
        .btn-danger:hover {
            background: rgba(255,50,50,0.35);
            box-shadow: 0 0 12px rgba(255,50,50,0.5);
        }
        .reset-confirm {
            display: none;
            margin-top: 10px;
            color: #ff4444;
            font-size: 13px;
        }
        .run-record {
            font-size: 13px;
            color: #00ffff;
            margin-top: 6px;
            opacity: 0.7;
        }

        /* ===== PRESTIGE GLOW ===== */
        @keyframes pulseGlow {
            0%   { filter: drop-shadow(0 0 4px gold); }
            50%  { filter: drop-shadow(0 0 12px gold); }
            100% { filter: drop-shadow(0 0 4px gold); }
        }
        .glow-gold { animation: pulseGlow 2s ease-in-out infinite; }
        .char-card.glow-gold-card {
            box-shadow: 0 0 14px 2px gold, inset 0 0 8px rgba(255,215,0,0.12);
            border-color: gold !important;
        }

        /* ===== VICTORY BADGE ===== */
        .victory-badge {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: default;
        }
        .victory-badge svg { width: 34px; height: 34px; filter: drop-shadow(0 0 5px gold); }
        .victory-badge .badge-tip {
            display: none;
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.92);
            color: gold;
            font-size: 12px;
            padding: 4px 10px;
            white-space: nowrap;
            border: 1px solid gold;
            pointer-events: none;
            z-index: 9998;
            font-family: 'Courier New', monospace;
        }
        .victory-badge:hover .badge-tip { display: block; }

        /* ===== HEADER ROW ===== */
        .header-title-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ===== HARD MODE TOGGLE ===== */
        .hard-mode-row {
            display: none;
            align-items: center;
            gap: 7px;
            margin-top: 6px;
            color: #ff4444;
            font-size: 13px;
            letter-spacing: 1px;
        }
        .hard-mode-row.unlocked { display: flex; }
        .hard-mode-row input { accent-color: #ff4444; cursor: pointer; }
        .hard-mode-row label { cursor: pointer; font-weight: bold; }
        /* v16: toggle disabled during active run — greyed out, no interaction */
        .hard-mode-row.run-locked {
            opacity: 0.38;
            pointer-events: none;
        }
        .hard-mode-row.run-locked label { cursor: default; }
        .hard-mode-row.run-locked .hm-pip {
            background: #555;
        }
        .hm-pip {
            font-size: 10px;
            background: #ff2222;
            color: #fff;
            padding: 2px 6px;
            border-radius: 2px;
            letter-spacing: 1px;
        }

        /* ===== GLOW TOGGLE ===== */
        .glow-toggle-row {
            display: none;
            align-items: center;
            gap: 7px;
            margin-top: 8px;
            color: gold;
            font-size: 13px;
        }
        .glow-toggle-row.unlocked { display: flex; }
        .glow-toggle-row input { accent-color: gold; cursor: pointer; }
        .glow-toggle-row label { cursor: pointer; }

        /* ===== UNLOCK BANNER ===== */
        .unlock-banner {
            display: none;
            background: linear-gradient(90deg, #1a0a00, #6b4a00, #1a0a00);
            border-bottom: 2px solid gold;
            color: gold;
            text-align: center;
            padding: 10px 16px;
            font-size: 15px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 10px gold;
            animation: bannerSlide 0.5s ease;
        }
        @keyframes bannerSlide {
            from { opacity: 0; transform: translateY(-16px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .unlock-banner.visible { display: block; }

        /* Hard Mode active indicator in HUD */
        .hm-active-tag {
            font-size: 11px;
            background: #ff2222;
            color: #fff;
            padding: 1px 6px;
            letter-spacing: 1px;
            margin-left: 6px;
            vertical-align: middle;
        }

        /* ===== TITLE SCREEN BADGE ===== */
        .title-badge-wrap {
            position: absolute;
            top: 18px;
            left: 18px;
            z-index: 10;
            display: none;
        }
        .title-badge-wrap.visible { display: block; }
        .title-badge-wrap img {
            width: 110px;
            height: 110px;
            object-fit: contain;
            filter: drop-shadow(0 0 10px rgba(0,200,255,0.6)) drop-shadow(0 0 4px rgba(180,0,255,0.5));
            transition: transform 0.2s ease;
        }
        .title-badge-wrap img:hover { transform: scale(1.06); }
        .title-badge-wrap .badge-tip {
            display: none;
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            background: rgba(0,0,0,0.92);
            color: #00ffff;
            font-size: 12px;
            padding: 4px 10px;
            white-space: nowrap;
            border: 1px solid #00ffff;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }
        .title-badge-wrap:hover .badge-tip { display: block; }
    
        /* ===== ARENA FX OVERLAY ===== */
        .arena-fx-pulse {
            animation: arenaPulse 3s ease-in-out infinite;
        }
        @keyframes arenaPulse {
            0%,100% { filter: brightness(1) saturate(1); }
            50%      { filter: brightness(1.08) saturate(1.15); }
        }
        #arenaSpotlight {
            position: absolute;
            top: 0; left: -120%;
            width: 60%; height: 100%;
            background: linear-gradient(105deg, transparent 30%, rgba(255,220,100,0.07) 50%, transparent 70%);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #arenaSpotlight.active { opacity: 1; }
        #crowdReactEl {
            position: absolute;
            top: 8px; left: 50%; transform: translateX(-50%);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 2px;
            color: #ffaa00;
            text-shadow: 0 0 8px #ffaa00;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        /* ===== LOCKED CARD ===== */
        .locked-card {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .locked-overlay {
            font-size: 28px;
            line-height: 1;
            padding: 20px 0 10px;
        }
        /* ============================================================
           v11: HARD CLEAR PRESTIGE REWARDS — CSS
           ============================================================ */

        /* 1) Hard Mode title badge — top-right, title screen only */
        .title-badge-wrap.hard-clear-badge {
            position: absolute;
            top: 18px;
            right: 18px;
            left: auto;            /* override .title-badge-wrap left:18px */
            z-index: 10;
            display: none;
            pointer-events: none;  /* no hover effects */
        }
        .title-badge-wrap.hard-clear-badge.visible { display: block; }
        .title-badge-wrap.hard-clear-badge img {
            width: 110px;
            height: 110px;
            object-fit: contain;
            animation: hardBadgePulse 3.8s ease-in-out infinite;
            /* no hover transform — pointer-events:none prevents it anyway */
        }
        /* v13: fighter portrait shown beneath the hard clear badge */
        #hardClearFighterIcon {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        #hardClearFighterIcon img {
            width: 48px;
            height: 68px;
            object-fit: contain;
            object-position: bottom;
            animation: none;          /* override badge pulse */
            filter: drop-shadow(0 0 4px rgba(180,0,0,0.6)) drop-shadow(0 0 10px rgba(120,0,0,0.35)) grayscale(0.2);
        }
        #hardClearFighterIcon .fighter-icon-label {
            font-family: 'Courier New', monospace;
            font-size: 9px;
            color: rgba(200, 60, 60, 0.9);
            letter-spacing: 0.1em;
            text-align: center;
            text-shadow: 0 0 6px rgba(180,0,0,0.7);
        }
        @keyframes hardBadgePulse {
            0%,100% { filter: drop-shadow(0 0 6px rgba(180,0,0,0.5)) drop-shadow(0 0 12px rgba(255,40,40,0.25)); }
            50%     { filter: drop-shadow(0 0 14px rgba(200,0,0,0.85)) drop-shadow(0 0 28px rgba(255,60,60,0.5)); }
        }

        /* 2) Crimson Glitch Outline — player sprite only */
        @keyframes crimsonGlitch {
            0%,92%,100% {
                filter: drop-shadow(0 0 6px rgba(180,0,0,0.55)) drop-shadow(0 0 14px rgba(140,0,0,0.3));
            }
            93% {
                filter: drop-shadow(2px 0 0 rgba(255,20,20,0.9)) drop-shadow(-1px 0 0 rgba(0,200,255,0.6)) drop-shadow(0 0 16px rgba(200,0,0,0.7));
                transform: translateX(2px);
            }
            94% {
                filter: drop-shadow(-2px 0 0 rgba(255,20,20,0.9)) drop-shadow(1px 0 0 rgba(0,200,255,0.6)) drop-shadow(0 0 18px rgba(200,0,0,0.8));
                transform: translateX(-2px);
            }
            95% {
                filter: drop-shadow(0 0 8px rgba(180,0,0,0.6));
                transform: translateX(0);
            }
            96% {
                filter: drop-shadow(2px 0 0 rgba(255,20,20,0.7)) drop-shadow(0 0 12px rgba(180,0,0,0.5));
                transform: translateX(1px);
            }
            97% {
                filter: drop-shadow(0 0 6px rgba(180,0,0,0.55));
                transform: translateX(0);
            }
        }
        /* Aura: pulsating crimson drop-shadow glow — no box, follows sprite silhouette */
        .prestige-crimson-outline {
            animation: crimsonAuraPulse 2.8s ease-in-out infinite;
        }
        @keyframes crimsonAuraPulse {
            0%,100% {
                filter: drop-shadow(0 0 4px rgba(160,0,0,0.5))
                        drop-shadow(0 0 10px rgba(120,0,0,0.25));
            }
            50% {
                filter: drop-shadow(0 0 8px rgba(210,0,0,0.75))
                        drop-shadow(0 0 20px rgba(160,0,0,0.45))
                        drop-shadow(0 0 32px rgba(100,0,0,0.2));
            }
        }
        /* Glitch flicker overlaid — fires every ~5s */
        .prestige-crimson-outline.glitch-tick {
            animation: crimsonGlitch 0.25s ease-in-out forwards;
        }

        /* 3) First Clash Spark Effect */
        .prestige-spark-flash {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120%;
            height: 24px;
            background: radial-gradient(ellipse at center, rgba(180,220,255,0.9) 0%, rgba(255,255,255,0.5) 40%, transparent 70%);
            pointer-events: none;
            z-index: 25;
            animation: sparkFlash 0.08s ease-out forwards;
        }
        @keyframes sparkFlash {
            0%  { opacity: 1; transform: translateX(-50%) scaleX(1); }
            100%{ opacity: 0; transform: translateX(-50%) scaleX(1.4); }
        }
        .prestige-spark-bolt {
            position: absolute;
            bottom: 4px;
            pointer-events: none;
            z-index: 26;
            font-size: 13px;
            color: rgba(180,220,255,0.95);
            text-shadow: 0 0 4px #fff, 0 0 8px rgba(100,180,255,0.8);
            animation: sparkBolt 0.22s ease-out forwards;
        }
        @keyframes sparkBolt {
            0%  { opacity: 1; transform: translateY(0) scale(1.2); }
            60% { opacity: 0.6; transform: translateY(-8px) scale(0.8); }
            100%{ opacity: 0; transform: translateY(-14px) scale(0.4); }
        }

        /* 4) Stability Bar Variant — crimson gradient for hard-cleared players */
        .stab-pip.prestige-crimson {
            background: linear-gradient(135deg, #8b0000 0%, #cc0022 50%, #ff2244 100%);
            border-color: #660011;
            box-shadow: 0 0 4px rgba(180,0,30,0.6);
        }
        .stab-pip.prestige-crimson.pulsing {
            animation: crimsonStabPulse 0.9s ease-in-out infinite;
        }
        @keyframes crimsonStabPulse {
            0%,100% { box-shadow: 0 0 3px rgba(180,0,30,0.5); filter: brightness(1); }
            50%     { box-shadow: 0 0 8px rgba(220,0,40,0.9); filter: brightness(1.25); }
        }
        .stab-pip.prestige-crimson.glitch {
            animation: crimsonStabGlitch 0.12s ease-in-out 3;
        }
        @keyframes crimsonStabGlitch {
            0%,100% { transform: translateX(0); filter: brightness(1) saturate(1); }
            33%  { transform: translateX(2px); filter: brightness(1.6) saturate(2) hue-rotate(-15deg); }
            66%  { transform: translateX(-1px); filter: brightness(0.8) saturate(1.5); }
        }

        /* 5) Hard Clear Victory Cinematic */
        #hardClearCinematic {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        #hardClearCinematic.active { display: block; }
        #hardClearText {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            z-index: 51;
        }
        #hardClearText.visible { opacity: 1; }
        .hcc-line1 {
            font-family: 'Courier New', monospace;
            font-size: 32px;
            font-weight: bold;
            color: #ff2244;
            letter-spacing: 0.22em;
            text-shadow: 0 0 20px rgba(220,0,40,0.9), 0 0 50px rgba(180,0,30,0.5),
                         3px 0 0 rgba(0,229,255,0.5), -3px 0 0 rgba(255,200,0,0.4);
            margin-bottom: 10px;
            animation: hccGlitch 0.25s ease-in-out 4;
        }
        .hcc-line2 {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #cc0022;
            letter-spacing: 0.3em;
            text-shadow: 0 0 12px rgba(180,0,30,0.8), 0 0 30px rgba(180,0,30,0.4);
            opacity: 0.9;
        }
        @keyframes hccGlitch {
            0%,100% { transform: translateX(0); text-shadow: 0 0 20px rgba(220,0,40,0.9), 0 0 50px rgba(180,0,30,0.5), 3px 0 0 rgba(0,229,255,0.5), -3px 0 0 rgba(255,200,0,0.4); }
            25%  { transform: translateX(4px);  text-shadow: 8px 0 0 rgba(0,229,255,0.8), -8px 0 0 rgba(255,200,0,0.7); }
            75%  { transform: translateX(-3px); text-shadow: -8px 0 0 rgba(0,229,255,0.8), 8px 0 0 rgba(255,200,0,0.7); }
        }
        #hardClearFade {
            position: absolute;
            inset: 0;
            background: #000;
            opacity: 0;
            z-index: 52;
            transition: opacity 0.8s ease;
        }
        #hardClearFade.active { opacity: 1; }

        /* ============================================================
           v14: COLISEUM CROWD REACTION SYSTEM — CSS
           ============================================================ */

        /* Dust particle burst on arena floor */
        .crowd-dust-canvas {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.08s ease;
        }
        .crowd-dust-canvas.active { opacity: 1; }

        /* Very subtle ground vibration — arena-content translateY pulse */
        @keyframes crowdVibrate {
            0%,100% { transform: translateY(0); }
            20%     { transform: translateY(-2px); }
            40%     { transform: translateY(1px); }
            60%     { transform: translateY(-1px); }
            80%     { transform: translateY(1px); }
        }
        .crowd-vibrate { animation: crowdVibrate 0.08s ease-out 1; }

        /* Boss meltdown: brief ambient warm flash on arena-bg */
        @keyframes crowdReverb {
            0%,100% { filter: brightness(1); }
            30%     { filter: brightness(1.06) sepia(0.08); }
        }
        .crowd-reverb-flash { animation: crowdReverb 0.3s ease-out 1; }

        /* ============================================================
           ARENA SOVEREIGN ENTRANCE SEQUENCE — v9 CSS
           ============================================================ */

        /* Darkening/vignette overlay on arena-bg */
        #sovereignDark {
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center,
                rgba(0,0,0,0) 40%,
                rgba(0,0,0,0.55) 100%),
                rgba(0,0,0,0);
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.6s ease;
        }
        #sovereignDark.active { opacity: 1; }

        /* Neon rain canvas — sits above bg, below sprites */
        #sovereignRain {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 7;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        #sovereignRain.active { opacity: 1; }

        /* Lightning flash — full arena */
        #sovereignFlash {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(200,230,255,0.95) 0%, rgba(180,200,255,0.9) 100%);
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.04s ease;
        }
        #sovereignFlash.active { opacity: 1; }
        @keyframes sovereignFlashKf {
            0%   { opacity: 1; }
            40%  { opacity: 0.85; }
            100% { opacity: 0; }
        }
        .sovereign-flash-anim {
            animation: sovereignFlashKf 0.12s ease-out forwards !important;
        }

        /* Shake on arena-content */
        @keyframes sovereignShake {
            0%,100% { transform: translateX(0); }
            15%  { transform: translateX(-5px); }
            35%  { transform: translateX(5px); }
            55%  { transform: translateX(-4px); }
            75%  { transform: translateX(3px); }
        }
        .sovereign-shake {
            animation: sovereignShake 0.22s ease-in-out !important;
        }

        /* Boss sprite entrance — starts in silhouette */
        .sovereign-boss-shadow img {
            filter: brightness(0) !important;
            opacity: 1 !important;
        }
        @keyframes sovereignReveal {
            0%   { filter: brightness(0); opacity: 0.7; }
            60%  { filter: brightness(0.4) sepia(1) hue-rotate(180deg) saturate(2); }
            100% { filter: brightness(1); }
        }
        .sovereign-boss-reveal img {
            animation: sovereignReveal 0.35s ease-out forwards !important;
        }

        /* Impact particles under boss */
        .sovereign-impact {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 25;
        }
        .sovereign-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: sovereignParticle var(--dur, 0.5s) ease-out forwards;
        }
        @keyframes sovereignParticle {
            0%   { opacity: 1; transform: translate(0,0) scale(1); }
            100% { opacity: 0; transform: translate(var(--dx,0px), var(--dy,-30px)) scale(0.3); }
        }

        /* Glitch title overlay — centered over arena */
        #sovereignTitle {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 30;
            opacity: 0;
        }
        #sovereignTitle.active { opacity: 1; }
        .sovereign-title-line1 {
            font-family: 'Courier New', monospace;
            font-size: 28px;
            font-weight: bold;
            color: #00e5ff;
            letter-spacing: 0.25em;
            text-shadow:
                0 0 12px rgba(0,229,255,0.9),
                0 0 30px rgba(0,229,255,0.5),
                2px 0 0 rgba(255,0,100,0.6),
                -2px 0 0 rgba(0,255,180,0.4);
            margin-bottom: 4px;
        }
        .sovereign-title-line2 {
            font-family: 'Courier New', monospace;
            font-size: 36px;
            font-weight: bold;
            color: #ff00cc;
            letter-spacing: 0.3em;
            text-shadow:
                0 0 16px rgba(255,0,204,0.9),
                0 0 40px rgba(255,0,204,0.5),
                3px 0 0 rgba(0,229,255,0.5),
                -3px 0 0 rgba(255,200,0,0.4);
        }
        @keyframes sovereignRgbSplit {
            0%,100% { text-shadow: 0 0 16px rgba(255,0,204,0.9), 0 0 40px rgba(255,0,204,0.5), 3px 0 0 rgba(0,229,255,0.5), -3px 0 0 rgba(255,200,0,0.4); transform: translateX(0); }
            25% { text-shadow: 0 0 16px rgba(255,0,204,0.9), 0 0 40px rgba(255,0,204,0.5), 8px 0 0 rgba(0,229,255,0.8), -8px 0 0 rgba(255,200,0,0.7); transform: translateX(3px); }
            75% { text-shadow: 0 0 16px rgba(255,0,204,0.9), 0 0 40px rgba(255,0,204,0.5), -8px 0 0 rgba(0,229,255,0.8), 8px 0 0 rgba(255,200,0,0.7); transform: translateX(-3px); }
        }
        .sovereign-title-glitch .sovereign-title-line2 {
            animation: sovereignRgbSplit 0.12s ease-in-out 3;
        }
        .sovereign-title-glitch .sovereign-title-line1 {
            animation: sovereignRgbSplit 0.12s ease-in-out 2;
        }

        /* Scanline glitch over title */
        #sovereignTitle::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(0deg,
                transparent,
                transparent 3px,
                rgba(0,229,255,0.04) 3px,
                rgba(0,229,255,0.04) 4px);
            pointer-events: none;
        }

        /* HUD desaturation during sequence */
        .sovereign-hud-dim {
            filter: saturate(0.8) brightness(0.7) !important;
            transition: filter 0.6s ease;
        }

        /* Enemy HP bar red tint for sovereign */
        .sovereign-hp-bar .hp-pip.enemy {
            background: #cc0033 !important;
            border-color: #880022 !important;
            box-shadow: 0 0 4px rgba(255,0,50,0.5);
        }

        /* Hard Mode final boss — deeper crimson HP bar */
        .sovereign-hp-bar-hard .hp-pip.enemy {
            background: #aa0000 !important;
            border-color: #660000 !important;
            box-shadow: 0 0 6px rgba(200,0,0,0.7), inset 0 0 4px rgba(0,0,0,0.5);
        }

        /* Pre-fight 30ms glitch ripple */
        @keyframes sovereignRipple {
            0%   { clip-path: inset(0 0 100% 0); opacity: 1; }
            30%  { clip-path: inset(30% 0 40% 0); opacity: 0.8; }
            60%  { clip-path: inset(60% 0 10% 0); opacity: 0.9; }
            100% { clip-path: inset(100% 0 0 0); opacity: 0; }
        }
        #sovereignRipple {
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg,
                rgba(0,229,255,0.15) 0%,
                rgba(255,0,204,0.1) 50%,
                rgba(0,229,255,0.15) 100%);
            pointer-events: none;
            z-index: 35;
            opacity: 0;
        }
        .sovereign-ripple-anim {
            animation: sovereignRipple 0.08s linear forwards !important;
        }

        /* ===== ARENA FX TOGGLE IN SETTINGS ===== */
        .arena-fx-row {
            display: none;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #888;
            margin-top: 4px;
        }
        .arena-fx-row.unlocked { display: flex; }
        .arena-fx-row label { cursor: pointer; }

        
        /* ===== GUNSHOT MUZZLE FLASH ===== */
        .muzzle-flash {
            position: absolute;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 30;
            animation: muzzleAnim 0.18s ease-out forwards;
        }
        .muzzle-flash.player-side {
            right: -10px;
            top: 40%;
        }
        .muzzle-flash.enemy-side {
            left: -10px;
            top: 40%;
        }
        @keyframes muzzleAnim {
            0%   { opacity: 1;   transform: scale(0.4); }
            40%  { opacity: 1;   transform: scale(1.1); }
            100% { opacity: 0;   transform: scale(0.8); }
        }
        .bullet-trail {
            position: absolute;
            height: 3px;
            top: calc(40% + 28px);
            background: linear-gradient(90deg, rgba(255,220,80,0.9), rgba(255,100,0,0.3), transparent);
            border-radius: 2px;
            pointer-events: none;
            z-index: 29;
            animation: bulletTrail 0.18s ease-out forwards;
        }
        .bullet-trail.player-side {
            left: 100%;
            width: 200px;
        }
        .bullet-trail.enemy-side {
            right: 100%;
            width: 200px;
            transform: scaleX(-1);
            transform-origin: right center;
        }
        @keyframes bulletTrail {
            0%   { opacity: 0.9; transform: scaleX(1); }
            100% { opacity: 0;   transform: scaleX(0.3); }
        }

        /* ============================================================
           v18: MOBILE-FIRST RESPONSIVE DESIGN
           All game logic/balance UNCHANGED. UI/UX only.
           ============================================================ */

        /* ── Global mobile safety ───────────────────────────────── */
        html { overflow-x: hidden; }
        body { overflow-x: hidden; }
        .app { overflow-x: hidden; }
        * { -webkit-tap-highlight-color: transparent; }

        /* Minimum tap target sizes for all interactive elements */
        .btn, .stance-btn, .tab-btn, .upgrade-card, .char-card {
            min-height: 48px;
            touch-action: manipulation;
        }

        /* Active/pressed feedback (touch-native) */
        .btn:active:not(:disabled),
        .stance-btn:active:not(:disabled),
        .tab-btn:active,
        .upgrade-card:active {
            transform: scale(0.97);
            opacity: 0.85;
        }
        .char-card:active { transform: scale(0.96); }

        /* ── Sticky mobile combat bar ───────────────────────────── */
        #mobileCombatBar {
            display: none;
            position: sticky;
            top: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 2px solid #ff00ff;
            padding: 8px 12px;
            box-shadow: 0 2px 12px rgba(255, 0, 255, 0.3);
        }
        .mcb-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        .mcb-fighter {
            flex: 1;
            min-width: 0;
        }
        .mcb-name {
            font-size: 11px;
            color: #888;
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .mcb-hp-row {
            display: flex;
            gap: 2px;
            margin-top: 3px;
            flex-wrap: wrap;
        }
        .mcb-pip {
            width: 12px;
            height: 10px;
            background: #00ff66;
            border: 1px solid #009933;
        }
        .mcb-pip.enemy { background: #ff4444; border-color: #cc0000; }
        .mcb-pip.empty { background: #330000; border-color: #440000; }
        .mcb-pip.stab  { background: #ffaa00; border-color: #cc8800; width: 10px; height: 10px; }
        .mcb-pip.stab.empty { background: #1a1a00; border-color: #333300; }
        .mcb-center {
            text-align: center;
            flex-shrink: 0;
        }
        .mcb-fight {
            font-size: 16px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }
        .mcb-clash {
            font-size: 10px;
            color: #666;
        }
        .mcb-right {
            flex: 1;
            min-width: 0;
            text-align: right;
        }
        .mcb-right .mcb-hp-row { justify-content: flex-end; }

        /* ── Collapsible details drawer ─────────────────────────── */
        #detailsDrawer {
            display: none;
        }
        .details-toggle {
            display: none;
            width: 100%;
            background: rgba(0,0,0,0.7);
            border: none;
            border-top: 1px solid #333;
            color: #888;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            padding: 8px 16px;
            text-align: left;
            cursor: pointer;
            letter-spacing: 1px;
            touch-action: manipulation;
            min-height: 40px;
        }
        .details-toggle:active { background: rgba(0,255,255,0.05); }
        .details-toggle .dt-arrow { float: right; transition: transform 0.2s; }
        .details-toggle.open .dt-arrow { transform: rotate(180deg); }

        /* ── Mobile tooltip panel (tap to show) ─────────────────── */
        #mobileFighterPanel {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: rgba(0,0,0,0.85);
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        #mobileFighterPanel.visible { display: flex; }
        .mfp-inner {
            background: rgba(5, 5, 20, 0.99);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 30px rgba(255,0,255,0.6);
            padding: 20px;
            width: 100%;
            max-width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        .mfp-close {
            position: absolute;
            top: 10px; right: 12px;
            font-size: 22px;
            color: #ff00ff;
            cursor: pointer;
            background: none;
            border: none;
            font-family: inherit;
            line-height: 1;
            touch-action: manipulation;
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mfp-img {
            width: 100%;
            height: 160px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin-bottom: 10px;
        }
        .mfp-name { font-size: 18px; font-weight: bold; color: #00ffff; margin-bottom: 4px; }
        .mfp-arch { font-size: 14px; color: #ff00ff; margin-bottom: 6px; font-weight: bold; }
        .mfp-weapon { font-size: 13px; color: #ffaa00; margin-bottom: 10px; }
        .mfp-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 10px;
        }
        .mfp-stat {
            font-size: 13px;
            color: #00ffff;
            background: rgba(0,255,255,0.08);
            padding: 5px 8px;
            border: 1px solid rgba(0,255,255,0.2);
        }
        .mfp-stat span { color: #fff; font-weight: bold; }
        .mfp-desc {
            font-size: 13px;
            color: #aaa;
            line-height: 1.6;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        .mfp-hp-bar {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        .mfp-hp-pip {
            width: 13px;
            height: 11px;
            background: #00ff66;
            border: 1px solid #009933;
        }

        /* ── Tap-info hint on char grid ─────────────────────────── */
        .tap-info-hint {
            display: none;
            text-align: center;
            color: #555;
            font-size: 12px;
            letter-spacing: 1px;
            padding: 6px 0 2px;
        }

        /* ============================================================
           TABLET BREAKPOINT — <= 768px
           ============================================================ */
        @media (max-width: 768px) {
            body { padding: 0; }
            .app { border-left: none; border-right: none; border-radius: 0; }

            .header { padding: 10px 14px; gap: 8px; flex-wrap: wrap; }
            .header .title {
                font-size: clamp(13px, 3.5vw, 20px);
                letter-spacing: 1px;
            }
            .run-info { font-size: 14px; }

            /* Arena content height adjusts */
            .arena-content { height: 460px; min-height: 460px; overflow: visible; }

            /* Fighter sprites scale down */
            .fighter-sprite { width: 150px; height: 210px; }

            /* Stance buttons — bigger touch targets */
            .stance-btn {
                padding: 14px 20px;
                font-size: 16px;
                min-width: 110px;
                min-height: 52px;
            }
            .stance-buttons { gap: 12px; }
            /* Fixed height prevents fighters from shifting during "Resolving..." */
            .stance-panel { height: 90px; min-height: 90px; padding: 10px 12px; }

            /* Upgrade cards stack nicely */
            .upgrade-card { width: 220px; }

            /* Char grid tighter */
            .char-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); }
        }

        /* ============================================================
           PHONE BREAKPOINT — <= 480px
           ============================================================ */
        @media (max-width: 480px) {
            body { padding: 0; background: #000; }

            /* ── Header ── */
            .header {
                padding: 8px 12px;
                flex-wrap: wrap;
                gap: 6px;
            }
            .header .title {
                font-size: clamp(11px, 3.8vw, 16px);
                letter-spacing: 0;
                line-height: 1.2;
            }
            .run-info { font-size: 13px; }
            .music-toggle { font-size: 13px; }

            /* ── Sticky mobile combat bar visible ── */
            #mobileCombatBar { display: block; }

            /* Show arena floor, not the stands in the middle of the image */
            #arenaBg { background-position: center bottom; }
            /* arena-screen is a flex column that fills available height */
            .arena-screen {
                display: flex;
                flex-direction: column;
                min-height: calc(100vh - 52px); /* subtract header height */
            }

            /* arena-content gets all remaining space after fixed-height panels */
            /* stance-panel: 100px + details-toggle: 40px = 140px fixed chrome below */
            .arena-content {
                flex: 1;
                min-height: 200px;
                overflow: visible; /* allow sprites to show fully */
            }

            /* HUD hidden — replaced by sticky bar */
            .hud { display: none; }

            /* Fighters area fills the flexible arena-content */
            .fighters-area {
                flex: 1;
                padding: 0 16px 20px; /* bottom padding = floor lift */
                min-height: 160px;
                align-items: flex-end;
            }
            .fighter-sprite { width: 100px; height: 150px; }
            .fighter-sprite.right.final-boss-sprite img { width: 160%; }

            /* Stance panel — fixed height so arena never shifts during "Resolving..." */
            .stance-panel {
                height: 100px;
                min-height: 100px;
                padding: 10px 10px 14px;
                border-top: 2px solid #ff00ff;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
            .stance-prompt { font-size: 14px; margin-bottom: 8px; }
            .stance-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 8px;
            }
            .stance-btn {
                padding: 16px 8px;
                font-size: 14px;
                min-width: 0;
                min-height: 58px;
                letter-spacing: 0;
                text-align: center;
            }

            /* Details toggle visible, clash log hidden until opened */
            .details-toggle { display: block; }
            .clash-log {
                height: 0;
                overflow: hidden;
                padding: 0;
                border: none;
                transition: height 0.25s ease;
            }
            .clash-log.open {
                height: 120px;
                padding: 6px 14px;
                border-top: 1px solid #333;
                overflow-y: auto;
            }

            /* Tap-info hint visible */
            .tap-info-hint { display: block; }

            /* Char grid — 3 columns on phone */
            .char-grid {
                grid-template-columns: repeat(3, 1fr);
                max-height: none;
                gap: 7px;
            }
            .char-card img { height: 80px; }
            .char-card .card-name { font-size: 10px; }
            .char-card .card-stats { font-size: 10px; }
            .char-card .card-weapon { font-size: 10px; }

            /* Hide desktop tooltip on phone */
            .char-tooltip { display: none !important; }

            /* Select info box compact */
            .select-info { padding: 10px 12px; }
            .select-info h3 { font-size: 15px; }
            .select-info .stat-line { font-size: 13px; }

            /* Buttons larger */
            .btn {
                padding: 16px 24px;
                font-size: 16px;
                width: 100%;
                max-width: 320px;
            }
            .btn-row { padding: 0 12px; }

            /* Select screen padding */
            .select-screen { padding: 12px; }
            .select-screen h2 {
                font-size: clamp(18px, 6vw, 26px);
            }

            /* Upgrade screen */
            .upgrade-screen { padding: 14px 12px; }
            .upgrade-screen h2 { font-size: 24px; }
            .upgrade-cards {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .upgrade-card {
                width: 100%;
                padding: 18px 16px;
                min-height: 80px;
            }
            .upgrade-card h3 { font-size: 17px; }
            .upgrade-card p { font-size: 14px; }

            /* Game over screen */
            .gameover-screen { padding: 24px 16px; }
            .gameover-screen h2 { font-size: 26px; }
            .gameover-screen .final-stats { font-size: 15px; }
            .meta-stats { gap: 12px; }
            .meta-stat-box { padding: 8px 12px; min-width: 70px; }
            .meta-stat-box .msb-val { font-size: 18px; }
            .btn-row[style*="flex"] {
                flex-direction: column;
                align-items: center;
            }

            /* How to play */
            .howtoplay { padding: 14px; max-height: none; }
            .howtoplay h3 { font-size: 17px; }
            .howtoplay p { font-size: 14px; }
            .archetype-grid { grid-template-columns: 1fr; }

            /* Title screen CTA text */
            .title-cta {
                font-size: clamp(14px, 4.5vw, 22px);
                letter-spacing: 2px;
                bottom: 5%;
                white-space: normal;
                text-align: center;
                width: 90%;
                left: 5%;
                transform: none;
            }

            /* Tab nav */
            .tab-btn {
                padding: 12px 16px;
                font-size: 14px;
                flex: 1;
                letter-spacing: 0;
            }

            /* HUD pips — smaller on phone to fit many HP */
            .hp-pip { width: 11px; height: 10px; }
            .stab-pip { width: 9px; height: 9px; }
        }

        /* ============================================================
           MOBILE LANDSCAPE — max-height: 480px AND max-width: 900px
           Phones rotated sideways. Arena needs to be compact but stable.
           ============================================================ */
        @media (max-height: 480px) and (max-width: 900px) {
            #mobileCombatBar { display: block; }
            .hud { display: none; }
            #arenaBg { background-position: center bottom; }

            /* Arena fills viewport height in landscape */
            .arena-screen {
                display: flex;
                flex-direction: column;
                min-height: calc(100vh - 48px);
            }
            .arena-content {
                flex: 1;
                min-height: 120px;
                overflow: visible;
            }
            .fighters-area {
                flex: 1;
                padding: 0 20px 8px;
                min-height: 100px;
                align-items: flex-end;
            }
            /* Smaller sprites in landscape */
            .fighter-sprite { width: 90px; height: 130px; }
            .fighter-sprite.right.final-boss-sprite img { width: 150%; }

            /* Stance panel locked height in landscape */
            .stance-panel {
                height: 80px;
                min-height: 80px;
                padding: 6px 10px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
            .stance-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 6px;
            }
            .stance-btn {
                padding: 10px 6px;
                font-size: 13px;
                min-height: 44px;
                letter-spacing: 0;
            }
            .stance-prompt { font-size: 13px; margin-bottom: 4px; }

            /* Clash log hidden by default in landscape too */
            .clash-log { height: 0; overflow: hidden; padding: 0; border: none; }
            .clash-log.open { height: 80px; padding: 4px 12px; border-top: 1px solid #333; overflow-y: auto; }
            .details-toggle { display: block; }
        }

        /* ============================================================
           prefers-reduced-motion
           ============================================================ */
        @media (prefers-reduced-motion: reduce) {
            .title-glitch-wrap .glitch-layer,
            .title-scan-flicker,
            .title-hbar,
            .title-noise,
            .starGlimmer,
            .arena-fx-pulse,
            .prestige-crimson-outline,
            .stab-pip.prestige-crimson.pulsing,
            .sovereign-particle,
            .muzzle-flash,
            .bullet-trail { animation: none !important; transition: none !important; }
        }

        /* ── Reduce heavy glow/shadow on mobile ─────────────────── */
        @media (max-width: 480px) {
            .app {
                box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
            }
            .header .title { text-shadow: 0 0 6px #ff00ff; }
            .select-screen h2 { text-shadow: 0 0 8px #ff00ff; }
            .gameover-screen h2 { text-shadow: 0 0 10px #ff00ff; }
            .upgrade-screen h2 { text-shadow: 0 0 8px #ff00ff; }
            /* Limit particle density hint — actual JS honours this flag */
            body { --mobile-particles: 1; }
        }

        </style>
</head>
<body>
<div class="app">

    <!-- TITLE SCREEN -->
    <div class="screen active" id="titleScreen">
        <!-- Normal clear badge — top-left -->
        <div class="title-badge-wrap" id="titleBadge">
            <img src="https://raw.githubusercontent.com/Redbarron007/Neo-Tokyo-Glitch-District-Arena/main/Champion_Badge.png" width="340" alt="Champion Badge">
            <div class="badge-tip">Cleared the Arena</div>
        </div>
        <!-- v11: Hard Mode clear badge — top-right, exclusive to title screen -->
        <div class="title-badge-wrap hard-clear-badge" id="titleHardBadge">
            <img src="https://github.com/user-attachments/assets/52cbdc46-3e97-476e-8fa2-d4443abcf3a8" alt="Hard Mode Champion">
            <!-- v13: fighter used to clear Hard Mode -->
            <div id="hardClearFighterIcon"></div>
        </div>
        <div class="title-screen" id="titleClickable" onclick="enterGame()">
            <div class="title-glitch-wrap">
                <img class="title-img" src="https://raw.githubusercontent.com/Redbarron007/Neo-Tokyo-Glitch-District-Arena/main/Title%20Screen.png" alt="Neo Tokyo Title">
                <div class="glitch-layer r"></div>
                <div class="glitch-layer b"></div>
                <div class="title-scan-flicker"></div>
                <div class="title-hbar"></div>
                <div class="title-noise"></div>
            </div>
            <div class="title-cta" id="titleCta">— CLICK TO PLAY —</div>
        </div>
    </div>

    <!-- Magnifier Tooltip -->
    <div class="char-tooltip" id="charTooltip">
        <img id="tooltipImg" src="" alt="">
        <div class="tt-name" id="tooltipName"></div>
        <div class="tt-archetype" id="tooltipArchetype"></div>
        <div class="tt-weapon" id="tooltipWeapon"></div>
        <div class="tt-stats" id="tooltipStats"></div>
        <div class="tt-hp-bar" id="tooltipHpBar"></div>
        <div class="tt-desc" id="tooltipDesc"></div>
    </div>
    <!-- Unlock Banner (first-clear reward notification) -->
    <div class="unlock-banner" id="unlockBanner"></div>

    <!-- v18: Mobile sticky combat bar (phone only, updated by renderArena) -->
    <div id="mobileCombatBar">
        <div class="mcb-row">
            <div class="mcb-fighter" id="mcbPlayer">
                <div class="mcb-name" id="mcbPlayerName">PLAYER</div>
                <div class="mcb-hp-row" id="mcbPlayerHp"></div>
                <div class="mcb-hp-row" id="mcbPlayerStab"></div>
            </div>
            <div class="mcb-center">
                <div class="mcb-fight" id="mcbFight">F1</div>
                <div class="mcb-clash" id="mcbClash"></div>
            </div>
            <div class="mcb-fighter mcb-right" id="mcbEnemy">
                <div class="mcb-name" id="mcbEnemyName">ENEMY</div>
                <div class="mcb-hp-row" id="mcbEnemyHp"></div>
                <div class="mcb-hp-row" id="mcbEnemyStab"></div>
            </div>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <div class="header-title-row">
            <div class="title">NEO TOKYO: GLITCH DISTRICT ARENA</div>
            </div>
        <div class="run-info" id="runInfo"></div>
        <div class="music-toggle" style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
            <label><input type="checkbox" id="musicToggle"> Music</label>
            <div class="hard-mode-row" id="hardModeRow">
                <input type="checkbox" id="hardModeToggle">
                <label for="hardModeToggle">HARD MODE</label>
                <span class="hm-pip">NEW</span>
            </div>
            <div class="arena-fx-row" id="arenaFxRow">
                <input type="checkbox" id="arenaFxToggle" checked>
                <label for="arenaFxToggle">Arena FX</label>
            </div>
        </div>
    </div>

    <!-- Character Select -->
    <div class="screen" id="selectScreen">
        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('roster')">Choose Fighter</button>
            <button class="tab-btn" onclick="switchTab('howtoplay')">How to Play</button>
        </div>

        <!-- Roster Tab -->
        <div class="tab-pane active select-screen" id="tabRoster">
            <h2>CHOOSE YOUR FIGHTER</h2>
            <div class="select-subtitle" style="display:flex;align-items:center;justify-content:center;gap:10px;flex-wrap:wrap;">
                Survive the gauntlet. Every win makes you stronger.
                </div>
            <p class="tap-info-hint">TAP FIGHTER TO PREVIEW · TAP AGAIN TO SELECT</p>
            <div class="glow-toggle-row" id="glowToggleRow" style="justify-content:center;">
                <input type="checkbox" id="glowToggle">
                <label for="glowToggle">Prestige Glow</label>
            </div>
            <div class="char-grid" id="charGrid"></div>
            <div class="select-info" id="selectInfo">
                <div style="color: #666; font-size: 14px;">Hover a fighter to preview · Click to select</div>
            </div>
            <div class="btn-row">
                <button class="btn" id="startRunBtn" disabled>Enter Arena</button>
            </div>
        </div>

        <!-- v18: Mobile fighter info panel (tap-to-show on phone) -->
        <div id="mobileFighterPanel">
            <div class="mfp-inner">
                <button class="mfp-close" id="mfpClose">✕</button>
                <img class="mfp-img" id="mfpImg" src="" alt="">
                <div class="mfp-name" id="mfpName"></div>
                <div class="mfp-arch" id="mfpArch"></div>
                <div class="mfp-weapon" id="mfpWeapon"></div>
                <div class="mfp-stats" id="mfpStats"></div>
                <div class="mfp-hp-bar" id="mfpHpBar"></div>
                <div class="mfp-desc" id="mfpDesc"></div>
                <div style="margin-top:16px;text-align:center;">
                    <button class="btn" id="mfpSelectBtn" style="width:100%;max-width:none;">SELECT THIS FIGHTER</button>
                </div>
            </div>
        </div>

        <!-- How to Play Tab -->
        <div class="tab-pane howtoplay" id="tabHowtoplay">
            <h3>⚔ The Gauntlet</h3>
            <p>Pick one fighter and battle through a randomized lineup of opponents. <span class="highlight">HP carries between fights</span> — play smart. After each victory, choose one upgrade. The goal: survive as long as possible.</p>

            <h3>📊 Fighter Stats</h3>
            <p>Every fighter has five stats that define how they fight:</p>
            <p>
                <span class="highlight">HP</span> — How much damage you can take before falling (6–12).<br>
                <span class="highlight">Power</span> — Base damage dealt each clash (1–4).<br>
                <span class="highlight">Speed</span> — Higher speed means you hit first. If your hit kills the enemy, they never strike back (1–4).<br>
                <span class="highlight">Guard</span> — Reduces incoming damage. Gun attacks ignore 1 Guard. Katanas ignore Guard when faster (0–3).<br>
                <span class="highlight">Weapon</span> — Gun or Katana. Changes damage rules and Stability gain.
            </p>

            <h3>🥊 The Stance System</h3>
            <p>Each clash you secretly pick a stance. The enemy does too. A <span class="highlight">triangle of advantage</span> determines who benefits:</p>
            <div class="stance-triangle">
                <div class="stance-box rush">RUSH<br><small>Aggressive</small></div>
                <div class="stance-arrow">→ beats →</div>
                <div class="stance-box zone">ZONE<br><small>Defensive</small></div>
                <div class="stance-arrow">→ beats →</div>
                <div class="stance-box counter">COUNTER<br><small>Reactive</small></div>
                <div class="stance-arrow">→ beats →</div>
                <div class="stance-box rush">RUSH</div>
            </div>
            <p>
                <span class="good">Advantage</span>: +2 damage dealt this clash.<br>
                <span class="danger">Disadvantage</span>: −1 damage dealt.<br>
                <span class="highlight">Neutral</span>: No modifier — pure stats decide it.
            </p>
            <p><strong>Bonus rules:</strong> Choosing <span class="warn">Counter</span> costs −1 Stability. Rushing with a <span class="warn">Katana</span> gains +1 Stability.</p>

            <h3>🌡 Stability & Overheat</h3>
            <p>Stability is your heat meter (0–5). It rises as you fight aggressively and falls if you choose Counter stance.</p>
            <p><strong>Stability rises when you:</strong> attack (+1), gain stance advantage (+1), take heavy damage ≥3 (+1), or Rush with a katana (+1).</p>
            <p>When Stability hits 5: <span class="warn">OVERHEAT</span>. Next clash you act second, deal −1 damage, no stance bonus, and Guard is ignored. Stability drops to 3, and a <span class="danger">2-clash danger window</span> opens.</p>
            <p>Overheat again during the danger window: <span class="danger">MELTDOWN</span>. You take 2 true damage, skip your attack, and Stability resets to 2. <em>Don't get greedy.</em></p>
            <div class="tip-box">💡 Tip: Use Counter stance to bleed off Stability when you're near 4–5. It costs −1 power but saves you from Overheat punishment.</div>

            <h3>🧠 Archetypes</h3>
            <p>Every fighter belongs to one of 8 archetypes that shape their AI behavior and grant special bonuses:</p>
            <div class="archetype-grid">
                <div class="archetype-card">
                    <div class="arch-name">⚔ Duelist</div>
                    <div class="arch-weapon">Gun or Katana</div>
                    <p>Deals +1 bonus damage in neutral clashes. Balanced stance approach — no obvious tell. Rewards players who can avoid giving advantages away.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">💥 Glass Cannon</div>
                    <div class="arch-weapon">Gun or Katana</div>
                    <p>Deals +2 bonus damage on the very first clash. Low HP, high threat. End the fight fast or get buried by the opener.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🛡 Juggernaut</div>
                    <div class="arch-weapon">Katana preferred</div>
                    <p>Takes −1 damage from any hit of 4 or more. Prefers Zone stance. Great at absorbing burst — chip them down steadily.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🗡 Assassin</div>
                    <div class="arch-weapon">Katana preferred</div>
                    <p>Deals +1 extra damage when they have stance advantage. Heavily favors Rush. If you let them read you, they punish hard.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🔄 Counterfighter</div>
                    <div class="arch-weapon">Gun or Katana</div>
                    <p>Heavily biased toward Counter stance. Watches your pattern and adapts fast. Vary your stance or get dismantled.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🎯 Zoner</div>
                    <div class="arch-weapon">Gun preferred</div>
                    <p>Prefers Zone stance. High guard values common. Resists Rush damage by design. Don't Rush into a Zoner — Zone or Counter them.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🔥 Berserker</div>
                    <div class="arch-weapon">Katana preferred</div>
                    <p>Deals +2 bonus damage at low HP (≤1/3 max HP). Pure Rush aggressor. Dangerous when cornered — don't let them survive long at low health.</p>
                </div>
                <div class="archetype-card">
                    <div class="arch-name">🎭 Trickster</div>
                    <div class="arch-weapon">Gun or Katana</div>
                    <p>Adds heavy randomness to stance weighting. Impossible to fully predict. Don't try to read them — play for your own stability.</p>
                </div>
            </div>

            <h3>⚡ Damage Formula</h3>
            <p><code style="color:#00ffff; background: rgba(0,255,255,0.1); padding: 4px 8px;">Damage = max(1, Power + StanceBonus + WeaponBonus − Guard)</code></p>
            <p>Gun: ignores 1 Guard. Katana: +1 damage if attacker is faster. Archetype bonuses apply on top of this.</p>

            <div class="tip-box">💡 Strategy tip: Watch the enemy's Stability bar. When they're at 4, bait an overheat — choose the stance that gives you advantage to push them to 5, then punish the weakened next clash.</div>
        </div>
    </div>

    <!-- Arena -->
    <div class="screen" id="arenaScreen">
        <div class="arena-screen">
            <div class="arena-bg" id="arenaBg">
                <div id="arenaSpotlight"></div>
                <div id="crowdReactEl"></div>
                <!-- v14: Coliseum Crowd dust canvas -->
                <canvas id="crowdDustCanvas" class="crowd-dust-canvas"></canvas>
                <!-- v9: Arena Sovereign Entrance overlays -->
                <div id="sovereignDark"></div>
                <canvas id="sovereignRain"></canvas>
                <div id="sovereignFlash"></div>
                <div id="sovereignTitle">
                    <div class="sovereign-title-line1">Citizen #0007</div>
                    <div class="sovereign-title-line2">ARENA SOVEREIGN</div>
                </div>
                <div id="sovereignRipple"></div>
            </div>
            <div class="arena-content">
                <div class="hud" id="hud"></div>
                <div class="fighters-area" id="fightersArea"></div>
                <div class="stance-panel" id="stancePanel"></div>
                <!-- v18: Collapsible details toggle (phone only) -->
                <button class="details-toggle" id="detailsToggle" onclick="toggleDetails()">
                    ▼ DETAILS <span class="dt-arrow">▲</span>
                </button>
                <div class="clash-log" id="clashLog"></div>
            </div>
            <!-- v11: Hard Clear Victory Cinematic overlay -->
            <div id="hardClearCinematic">
                <div id="hardClearText">
                    <div class="hcc-line1">SYSTEM OVERRIDDEN</div>
                    <div class="hcc-line2">ARENA PROTOCOL BREACHED</div>
                </div>
                <div id="hardClearFade"></div>
            </div>
        </div>
    </div>

    <!-- Upgrade Screen -->
    <div class="screen" id="upgradeScreen">
        <div class="upgrade-screen">
            <h2>VICTORY</h2>
            <div class="upgrade-subtitle" id="upgradeSubtitle"></div>
            <div class="upgrade-cards" id="upgradeCards"></div>
        </div>
    </div>

    <!-- Game Over -->
    <div class="screen" id="gameoverScreen">
        <div class="gameover-screen">
            <div style="display:flex;align-items:center;justify-content:center;gap:12px;">
                <h2 id="gameoverTitle">DEFEATED</h2>
            </div>
            <div class="final-stats" id="finalStats"></div>
            <div class="meta-stats" id="metaStatsDisplay"></div>
            <div class="btn-row" style="display:flex;gap:15px;justify-content:center;align-items:center;flex-wrap:wrap;">
                <button class="btn" id="restartBtn">Try Again</button>
                <button class="btn btn-danger" id="resetProgressBtn">Reset Progress</button>
            </div>
            <div class="reset-confirm" id="resetConfirm">
                Are you sure? This cannot be undone.
                <button class="btn btn-danger" id="resetConfirmYes" style="margin-left:10px;font-size:12px;padding:5px 14px;">Confirm Reset</button>
                <button class="btn" id="resetConfirmNo" style="margin-left:6px;font-size:12px;padding:5px 14px;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script>
// ============================================================
// SPRITE INFRASTRUCTURE (kept from original)
// ============================================================
const SPRITE_BASE = 'https://raw.githubusercontent.com/Redbarron007/game-assets/main/sprites';
const BG_URL = `${SPRITE_BASE}/arena_bg.png`;

const embeddedImages = {};
const spriteTypes = ['', '_gun', '_katana', '_Overheated', '_katana_attack', '_death', '_dysentery', '_gun_attack'];

for (let i = 1; i <= 20; i++) {
    spriteTypes.forEach(type => {
        let gameKey;
        if (type === '') gameKey = `char_${i}.png`;
        else if (type === '_Overheated') gameKey = `char_${i}_overheated.png`;
        else if (type === '_dysentery') gameKey = `char_${i}_dysentery_death.png`;
        else gameKey = `char_${i}${type}.png`;
        embeddedImages[gameKey] = `${SPRITE_BASE}/Char_${i}${type}.png`;
    });
}
for (let i = 21; i <= 42; i++) {
    spriteTypes.forEach(type => {
        let gameKey, githubName;
        if (type === '') { gameKey = `char_${i}.png`; githubName = `Char_${i}_idle.png`; }
        else if (type === '_Overheated') { gameKey = `char_${i}_overheated.png`; githubName = `Char_${i}_Overheated.png`; }
        else if (type === '_dysentery') { gameKey = `char_${i}_dysentery_death.png`; githubName = `Char_${i}_dysentery.png`; }
        else { gameKey = `char_${i}${type}.png`; githubName = `Char_${i}${type}.png`; }
        embeddedImages[gameKey] = `${SPRITE_BASE}/${githubName}`;
    });
}

function spriteUrl(charId, pose) {
    // pose: 'idle', 'gun', 'gun_attack', 'katana', 'katana_attack', 'death', 'overheated', 'dysentery_death'

    // v10: UAEC Sovereign Frame — Hard Mode final boss (id 99)
    if (charId === 99) {
        const GHUB = 'https://github.com/user-attachments/assets/';
        const finalBossMap = {
            idle:                  GHUB + 'c189da7a-6ccf-4110-865d-bd14588ceb23',
            gun:                   GHUB + 'c189da7a-6ccf-4110-865d-bd14588ceb23', // default idle stance
            railburst_cannon:      GHUB + 'f16c6bb3-8d43-49a2-bfce-aa82136b2dfe',
            suppression_barrage:   GHUB + '31fea3ce-066e-4c49-abee-76c44648f0cc',
            reactive_plating:      GHUB + 'b93217ea-67b3-4255-85ed-16ab4c7ce431',
            overheated:            GHUB + 'f45e043a-26dd-4318-835d-21c19c965450',
            injured:               GHUB + 'f45e043a-26dd-4318-835d-21c19c965450', // share overheated as injured
            death:                 GHUB + '536458c2-4285-44f1-8b5c-e3d350dd0ffb',
            dysentery_death:       GHUB + '536458c2-4285-44f1-8b5c-e3d350dd0ffb',
            gun_attack:            GHUB + 'f16c6bb3-8d43-49a2-bfce-aa82136b2dfe', // railburst for standard attack
        };
        // Override: if fighter has a current pose flag use it, otherwise resolve from pose key
        return finalBossMap[pose] || finalBossMap['idle'];
    }

    // Special handling for milestone characters 7 and 8 with exact filenames
    if (charId === 7 || charId === 8) {
        const map7 = {
            idle: 'Char_7.png', gun: 'Char_7_gun.png', gun_attack: 'Char_7_gun_attack.png',
            katana: 'Char_7_katana.png', katana_attack: 'Char_7_katana_attack.png',
            overheated: 'Char_7_Overheated.png', dysentery_death: 'Char_7_dysentery.png', death: 'Char_7_death.png',
        };
        const map8 = {
            idle: 'Char_8.png', gun: 'Char_8_gun.png', gun_attack: 'Char_8_gun_attack.png',
            katana: 'Char_8_katana.png', katana_attack: 'Char_8_katana_attack.png',
            overheated: 'Char_8_Overheated.png', dysentery_death: 'Char_8_dysentery.png', death: 'Char_8_death.png',
        };
        const map = charId === 7 ? map7 : map8;
        const filename = map[pose] || map['idle'];
        return `${SPRITE_BASE}/${filename}`;
    }
    let key;
    if (pose === 'idle') key = `char_${charId}.png`;
    else if (pose === 'overheated') key = `char_${charId}_overheated.png`;
    else if (pose === 'dysentery_death') key = `char_${charId}_dysentery_death.png`;
    else key = `char_${charId}_${pose}.png`;
    return embeddedImages[key] || key;
}

// ============================================================
// SOUND EFFECTS
// ============================================================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
document.addEventListener('click', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true });

const bgMusic = new Audio('https://raw.githubusercontent.com/Redbarron007/game-assets/main/sprites/10158b47-cfc7-41fa-bdcb-48e8283a4586.mp3');
bgMusic.loop = true;
bgMusic.volume = 0.2;

document.getElementById('musicToggle').addEventListener('change', e => {
    if (e.target.checked) bgMusic.play().catch(() => {});
    else bgMusic.pause();
    updateSetting('musicOn', e.target.checked);
});

function playSound(type) {
    try {
        const t = audioCtx.currentTime;
        if (type === 'laser') {
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(1200, t);
            o.frequency.exponentialRampToValueAtTime(100, t + 0.3);
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            o.start(t); o.stop(t + 0.3);
        } else if (type === 'sword') {
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.25, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) { const tt = i / audioCtx.sampleRate; d[i] = (Math.random() * 2 - 1) * Math.exp(-tt * 15) * 0.4; }
            const s = audioCtx.createBufferSource(); s.buffer = buf;
            const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass';
            hp.frequency.setValueAtTime(2000, t); hp.frequency.exponentialRampToValueAtTime(800, t + 0.15);
            s.connect(hp); hp.connect(audioCtx.destination); s.start(t);
        } else if (type === 'thud') {
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = 'sine'; o.frequency.setValueAtTime(80, t); o.frequency.exponentialRampToValueAtTime(30, t + 0.2);
            g.gain.setValueAtTime(0.9, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t + 0.3);
        } else if (type === 'sparks') {
            for (let b = 0; b < 5; b++) {
                const delay = b * 0.06 + Math.random() * 0.03;
                const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.04), audioCtx.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) { d[i] = (Math.random() * 2 - 1) * Math.exp(-(i / audioCtx.sampleRate) * 60) * 0.35; }
                const s = audioCtx.createBufferSource(); s.buffer = buf;
                const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 3000 + Math.random() * 4000; bp.Q.value = 5;
                const g = audioCtx.createGain(); g.gain.setValueAtTime(0.4, t + delay);
                s.connect(bp); bp.connect(g); g.connect(audioCtx.destination); s.start(t + delay);
            }
        } else if (type === 'fart') {
            const o = audioCtx.createOscillator(), g = audioCtx.createGain(), lfo = audioCtx.createOscillator(), lg = audioCtx.createGain();
            o.type = 'sawtooth'; o.frequency.setValueAtTime(80, t); o.frequency.linearRampToValueAtTime(50, t + 0.4);
            lfo.frequency.value = 25; lg.gain.value = 30; lfo.connect(lg); lg.connect(o.frequency);
            const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass';
            lp.frequency.setValueAtTime(300, t); lp.frequency.linearRampToValueAtTime(100, t + 0.5);
            g.gain.setValueAtTime(0.7, t); g.gain.setValueAtTime(0.7, t + 0.25); g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
            o.connect(lp); lp.connect(g); g.connect(audioCtx.destination);
            lfo.start(t); o.start(t); o.stop(t + 0.5); lfo.stop(t + 0.5);
        }
    } catch(e) {}
}

// ============================================================
// GAME DATA
// ============================================================
const ARCHETYPES = {
    duelist:       { name: 'Duelist',       desc: 'Bonus damage in neutral clashes', stanceBias: { rush: 1, counter: 1, zone: 1 } },
    glasscannon:   { name: 'Glass Cannon',  desc: 'Strong opening hit, fragile', stanceBias: { rush: 2, counter: 0, zone: 1 } },
    juggernaut:    { name: 'Juggernaut',    desc: 'Resists burst damage', stanceBias: { rush: 1, counter: 1, zone: 2 } },
    elite_duelist: { name: 'Elite Duelist',  desc: 'Stance wins reduce Stability & boost Guard', stanceBias: { rush: 1, counter: 2, zone: 1 } },
    assassin:      { name: 'Assassin',      desc: 'Extra damage from stance advantage', stanceBias: { rush: 2, counter: 1, zone: 0 } },
    counterfighter:{ name: 'Counterfighter', desc: 'Punishes predictable patterns', stanceBias: { rush: 0, counter: 3, zone: 0 } },
    zoner:         { name: 'Zoner',         desc: 'Strong at range, resists rush', stanceBias: { rush: 0, counter: 1, zone: 3 } },
    berserker:     { name: 'Berserker',     desc: 'Stronger at low HP', stanceBias: { rush: 3, counter: 0, zone: 0 } },
    trickster:     { name: 'Trickster',     desc: 'Unpredictable stance choices', stanceBias: { rush: 1, counter: 1, zone: 1 } },
};

const ARCHETYPE_KEYS = Object.keys(ARCHETYPES);

function seededRandom(seed) {
    let s = seed;
    return function() { s = (s * 16807 + 0) % 2147483647; return s / 2147483647; };
}

// Explicit fighter roster (24 characters) — v3 balanced
// Changes from original: HP floor 8, guard floor 1, #2481 nerfed, high-HP low-power chars get +1 power
const ALL_FIGHTERS = [
    { id: 1,  name: `Citizen #2915`, archetype: 'duelist',        baseHp: 9,  power: 3, speed: 4, guard: 2, weapon: 'gun' },
    { id: 5,  name: `Citizen #1578`, archetype: 'counterfighter', baseHp: 9,  power: 3, speed: 3, guard: 3, weapon: 'gun' },
    { id: 3,  name: `Citizen #3746`, archetype: 'berserker',      baseHp: 9,  power: 3, speed: 4, guard: 1, weapon: 'katana' },
    { id: 4,  name: `Citizen #2662`, archetype: 'assassin',       baseHp: 8,  power: 3, speed: 4, guard: 1, weapon: 'katana' },
    { id: 2,  name: `Citizen #1831`, archetype: 'juggernaut',     baseHp: 10, power: 3, speed: 2, guard: 3, weapon: 'katana' },
    { id: 6,  name: `Citizen #3493`, archetype: 'zoner',          baseHp: 9,  power: 3, speed: 3, guard: 2, weapon: 'gun' },
    { id: 9,  name: `Citizen #3240`, archetype: 'berserker',      baseHp: 9,  power: 4, speed: 2, guard: 3, weapon: 'katana' },
    { id: 11, name: `Citizen #1072`, archetype: 'glasscannon',    baseHp: 8,  power: 4, speed: 3, guard: 1, weapon: 'katana' },
    { id: 13, name: `Citizen #1903`, archetype: 'duelist',        baseHp: 10, power: 4, speed: 2, guard: 1, weapon: 'gun' },
    { id: 18, name: `Citizen #2481`, archetype: 'zoner',          baseHp: 9,  power: 3, speed: 4, guard: 2, weapon: 'gun' },
    { id: 20, name: `Citizen #3312`, archetype: 'duelist',        baseHp: 9,  power: 3, speed: 4, guard: 2, weapon: 'gun' },
    { id: 21, name: `Citizen #2228`, archetype: 'counterfighter', baseHp: 9,  power: 4, speed: 3, guard: 2, weapon: 'katana' },
    { id: 23, name: `Citizen #3059`, archetype: 'trickster',      baseHp: 9,  power: 3, speed: 4, guard: 2, weapon: 'katana' },
    { id: 24, name: `Citizen #1975`, archetype: 'juggernaut',     baseHp: 10, power: 3, speed: 2, guard: 3, weapon: 'katana' },
    { id: 28, name: `Citizen #3637`, archetype: 'assassin',       baseHp: 9,  power: 4, speed: 2, guard: 2, weapon: 'katana' },
    { id: 30, name: `Citizen #1469`, archetype: 'berserker',      baseHp: 9,  power: 4, speed: 2, guard: 2, weapon: 'katana' },
    { id: 31, name: `Citizen #3384`, archetype: 'trickster',      baseHp: 9,  power: 2, speed: 4, guard: 2, weapon: 'gun' },
    { id: 33, name: `Citizen #1216`, archetype: 'counterfighter', baseHp: 10, power: 3, speed: 4, guard: 1, weapon: 'gun' },
    { id: 36, name: `Citizen #3963`, archetype: 'juggernaut',     baseHp: 11, power: 3, speed: 4, guard: 2, weapon: 'katana' },
    { id: 38, name: `Citizen #1794`, archetype: 'zoner',          baseHp: 11, power: 2, speed: 2, guard: 3, weapon: 'gun' },
    { id: 39, name: `Citizen #3709`, archetype: 'trickster',      baseHp: 10, power: 3, speed: 4, guard: 1, weapon: 'katana' },
    { id: 40, name: `Citizen #2625`, archetype: 'assassin',       baseHp: 9,  power: 3, speed: 3, guard: 3, weapon: 'katana' },
    { id: 42, name: `Citizen #3456`, archetype: 'glasscannon',    baseHp: 8,  power: 3, speed: 2, guard: 1, weapon: 'gun' },
    { id: 41, name: `Citizen #1541`, archetype: 'glasscannon',    baseHp: 8,  power: 4, speed: 2, guard: 1, weapon: 'katana' },
    // ── Milestone-unlocked characters (hidden until earned) ──
    { id: 8,  name: `Character 8`,   archetype: 'juggernaut',   baseHp: 12, power: 2, speed: 1, guard: 3, weapon: 'gun',    trait: 'shock_absorbers',       _locked: true },
    { id: 7,  name: `Character 7`,   archetype: 'elite_duelist',baseHp: 9,  power: 3, speed: 3, guard: 2, weapon: 'katana', trait: 'stability_feedback_loop',_locked: true },
];

// ============================================================
// GAME STATE
// ============================================================
let run = null; // current run state

function newFighterState(fighter) {
    return {
        ...fighter,
        hp: fighter.baseHp,
        maxHp: fighter.baseHp,
        stability: 0,
        overheatActive: false,
        meltdownActive: false,
        dangerWindow: 0,
        neuralOverclocked: 0,     // Neural Upgrade count — adds this many stability per attack
    };
}

// ============================================================
// SCREENS
// ============================================================
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    if (id !== 'arenaScreen') ArenaFX.enable(false);
    // v16: Hard Mode toggle is only valid on title/select screens.
    // Lock it (visual + interaction) during any active run screen.
    const hmRow = document.getElementById('hardModeRow');
    if (hmRow) {
        const runActive = (id === 'arenaScreen' || id === 'upgradeScreen' || id === 'gameoverScreen');
        hmRow.classList.toggle('run-locked', runActive);
        const toggle = document.getElementById('hardModeToggle');
        if (toggle) toggle.disabled = runActive;
    }
}

// ============================================================
// CHARACTER SELECT
// ============================================================
let selectedFighterId = null;

function renderCharSelect() {
    const grid = document.getElementById('charGrid');
    grid.innerHTML = '';
    // v15: build set of fighter IDs that have cleared Hard Mode for O(1) lookup
    const hardClearIds = new Set(saveData.meta.hardClearFighterIds || []);

    // Show all fighters: locked ones appear as locked unless unlocked in save
    ALL_FIGHTERS.forEach(f => {
        const isUnlocked = !f._locked || saveData.meta.unlockedCharacters.includes(f.id);
        const card = document.createElement('div');
        card.className = 'char-card' + (f._locked && !isUnlocked ? ' locked-card' : '');
        card.dataset.id = f.id;
        const arch = ARCHETYPES[f.archetype];
        // v15: gold star for any fighter that has cleared Hard Mode
        const starHTML = hardClearIds.has(f.id)
            ? `<div class="hard-clear-star" title="Hard Mode Cleared">⭐</div>`
            : '';
        if (f._locked && !isUnlocked) {
            card.innerHTML = `
                <div class="locked-overlay">🔒</div>
                <div class="card-name" style="color:#555">${f.name}</div>
                <div class="card-stats" style="color:#444">???</div>
                <div class="card-weapon" style="color:#444">LOCKED</div>
            `;
        } else {
            card.innerHTML = `
                ${starHTML}
                <img src="${spriteUrl(f.id, f.weapon)}" onerror="this.style.display='none'">
                <div class="card-name">${f.name}</div>
                <div class="card-stats">HP:${f.baseHp} P:${f.power} S:${f.speed} G:${f.guard}</div>
                <div class="card-weapon">${f.weapon.toUpperCase()} · ${arch.name}</div>
            `;
            card.addEventListener('click', () => selectFighter(f.id));
        }
        grid.appendChild(card);
    });
}

function selectFighter(id) {
    selectedFighterId = id;
    document.querySelectorAll('.char-card').forEach(c => c.classList.toggle('selected', parseInt(c.dataset.id) === id));
    document.getElementById('startRunBtn').disabled = false;

    const f = ALL_FIGHTERS.find(x => x.id === id);
    const arch = ARCHETYPES[f.archetype];
    document.getElementById('selectInfo').innerHTML = `
        <h3>${f.name} — ${arch.name}</h3>
        <div class="stat-line">HP: ${f.baseHp} | Power: ${f.power} | Speed: ${f.speed} | Guard: ${f.guard}</div>
        <div class="stat-line">Weapon: ${f.weapon.toUpperCase()}</div>
        <div class="archetype-desc">${arch.desc}</div>
    `;
}

document.getElementById('startRunBtn').addEventListener('click', () => {
    if (!selectedFighterId) return;
    startRun(selectedFighterId);
});
document.getElementById('restartBtn').addEventListener('click', () => {
    selectedFighterId = null;
    renderCharSelect();
    showScreen('selectScreen');
});

// ============================================================
// ARENA SOVEREIGN ENTRANCE SEQUENCE — v9
// Triggers: Normal mode, fight 24 only. Once per run.
// Pure visual + audio — zero effect on game mechanics.
// Total duration: ~3000ms. Input re-enabled at 3500ms max.
// ============================================================
const SovereignEntrance = (() => {
    let _rainController = null;
    let _droneNodes = null;
    let _hasPlayed = false; // once per run

    // ── Audio: sub-bass drone ──────────────────────────────────
    function startDrone() {
        try {
            const ctx = audioCtx;
            const masterGain = ctx.createGain();
            masterGain.gain.setValueAtTime(0, ctx.currentTime);
            masterGain.gain.linearRampToValueAtTime(0.18, ctx.currentTime + 0.6);
            masterGain.connect(ctx.destination);

            const sub = ctx.createOscillator();
            sub.type = 'sine'; sub.frequency.value = 42;
            const subGain = ctx.createGain(); subGain.gain.value = 0.9;
            sub.connect(subGain); subGain.connect(masterGain);

            const harm = ctx.createOscillator();
            harm.type = 'triangle'; harm.frequency.value = 84;
            const harmGain = ctx.createGain(); harmGain.gain.value = 0.15;
            harm.connect(harmGain); harmGain.connect(masterGain);

            const lfo = ctx.createOscillator();
            lfo.type = 'sine'; lfo.frequency.value = 0.3;
            const lfoGain = ctx.createGain(); lfoGain.gain.value = 8;
            lfo.connect(lfoGain); lfoGain.connect(sub.frequency);

            sub.start(); harm.start(); lfo.start();
            _droneNodes = { sub, harm, lfo, masterGain };
        } catch(e) {}
    }

    function fadeDrone(durationMs) {
        if (!_droneNodes) return;
        try {
            const { masterGain, sub, harm, lfo } = _droneNodes;
            const ctx = audioCtx;
            masterGain.gain.setValueAtTime(masterGain.gain.value, ctx.currentTime);
            masterGain.gain.linearRampToValueAtTime(0, ctx.currentTime + durationMs / 1000);
            setTimeout(() => {
                try { sub.stop(); harm.stop(); lfo.stop(); } catch(e) {}
                _droneNodes = null;
            }, durationMs + 100);
        } catch(e) {}
    }

    // ── Audio: thunder crack + metallic echo ──────────────────
    function playThunder() {
        try {
            const ctx = audioCtx;
            const t = ctx.currentTime;
            const bufLen = ctx.sampleRate * 1.2;
            const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufLen; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.3));
            }
            const src = ctx.createBufferSource(); src.buffer = buf;
            const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 280;
            const g = ctx.createGain();
            g.gain.setValueAtTime(1.2, t); g.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
            src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(t);

            for (let echo = 0; echo < 3; echo++) {
                const delay = 0.12 + echo * 0.18;
                const echoBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.05), ctx.sampleRate);
                const ed = echoBuf.getChannelData(0);
                for (let i = 0; i < ed.length; i++) {
                    ed[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.015)) * (0.5 - echo * 0.12);
                }
                const es = ctx.createBufferSource(); es.buffer = echoBuf;
                const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 1800;
                const eg = ctx.createGain(); eg.gain.value = 0.4 / (echo + 1);
                es.connect(hp); hp.connect(eg); eg.connect(ctx.destination); es.start(t + delay);
            }
        } catch(e) {}
    }

    // ── Neon rain canvas ──────────────────────────────────────
    function initRain() {
        const canvas = document.getElementById('sovereignRain');
        if (!canvas) return null;
        const arenaBg = document.getElementById('arenaBg');
        canvas.width  = arenaBg ? (arenaBg.offsetWidth  || 800) : 800;
        canvas.height = arenaBg ? (arenaBg.offsetHeight || 620) : 620;
        const ctx2d = canvas.getContext('2d');

        const streaks = Array.from({ length: 60 }, () => ({
            x:        Math.random() * canvas.width,
            y:        Math.random() * canvas.height,
            len:      18 + Math.random() * 38,
            speed:    3.5 + Math.random() * 5,
            color:    Math.random() < 0.55 ? '#00eeff' : '#ff00cc',
            alpha:    0.4 + Math.random() * 0.5,
            parallax: 0.7 + Math.random() * 0.6,
            bright:   Math.random() < 0.2,
        }));

        let _intensity = 1.0;
        let _running = true;
        let _frameId = null;

        function draw() {
            if (!_running) return;
            ctx2d.clearRect(0, 0, canvas.width, canvas.height);
            for (const s of streaks) {
                const alpha = s.alpha * _intensity;
                const grad = ctx2d.createLinearGradient(s.x, s.y, s.x, s.y + s.len);
                const hex = Math.round(Math.max(0, Math.min(255, alpha * 255))).toString(16).padStart(2,'0');
                grad.addColorStop(0, `${s.color}00`);
                grad.addColorStop(0.4, `${s.color}${hex}`);
                grad.addColorStop(1, `${s.color}00`);
                ctx2d.beginPath();
                ctx2d.strokeStyle = grad;
                ctx2d.lineWidth = s.bright ? 2 : 1;
                ctx2d.shadowColor = s.color;
                ctx2d.shadowBlur  = s.bright ? 8 : 3;
                ctx2d.moveTo(s.x, s.y);
                ctx2d.lineTo(s.x, s.y + s.len);
                ctx2d.stroke();
                ctx2d.shadowBlur = 0;

                const floorY = canvas.height * 0.82;
                if (s.y + s.len > floorY && alpha > 0.05) {
                    const refAlpha = alpha * 0.15;
                    const refHex = Math.round(Math.max(0, Math.min(255, refAlpha * 255))).toString(16).padStart(2,'0');
                    ctx2d.beginPath();
                    ctx2d.strokeStyle = `${s.color}${refHex}`;
                    ctx2d.lineWidth = 1;
                    const refLen = Math.min(s.len * 0.5, (s.y + s.len - floorY) * 0.4);
                    ctx2d.moveTo(s.x + (Math.random() - 0.5) * 4, floorY);
                    ctx2d.lineTo(s.x + (Math.random() - 0.5) * 6, floorY + refLen);
                    ctx2d.stroke();
                }

                s.y += s.speed * s.parallax;
                if (s.y > canvas.height) { s.y = -s.len; s.x = Math.random() * canvas.width; }
            }
            _frameId = requestAnimationFrame(draw);
        }
        draw();

        return {
            setIntensity(v) { _intensity = Math.max(0, v); },
            stop() { _running = false; if (_frameId) { cancelAnimationFrame(_frameId); _frameId = null; } },
        };
    }

    // ── Impact particles under boss sprite ────────────────────
    function spawnImpact() {
        const enemyEl = document.getElementById('enemySprite');
        if (!enemyEl) return;
        const wrap = document.createElement('div');
        wrap.className = 'sovereign-impact';
        const colors = ['#00eeff','#ff00cc','#ffffff','#ffee00'];
        for (let i = 0; i < 14; i++) {
            const p = document.createElement('div');
            p.className = 'sovereign-particle';
            const angle = (Math.random() * 180 - 90) * (Math.PI / 180);
            const dist  = 20 + Math.random() * 50;
            p.style.setProperty('--dx',  `${Math.sin(angle) * dist}px`);
            p.style.setProperty('--dy',  `-${Math.abs(Math.cos(angle) * dist * 0.6)}px`);
            p.style.setProperty('--dur', `${0.3 + Math.random() * 0.35}s`);
            p.style.background    = colors[i % colors.length];
            p.style.left          = `${40 + Math.random() * 20}%`;
            p.style.boxShadow     = `0 0 6px ${p.style.background}`;
            p.style.animationDelay = `${Math.random() * 0.06}s`;
            wrap.appendChild(p);
        }
        enemyEl.appendChild(wrap);
        setTimeout(() => { try { wrap.remove(); } catch(e) {} }, 900);
    }

    // ── Main sequence ─────────────────────────────────────────
    // titleConfig: optional { line1: string, line2: string } — defaults to Normal boss text
    function play(onComplete, titleConfig) {
        if (_hasPlayed) { onComplete(); return; }
        _hasPlayed = true;

        // Apply title text before sequence starts
        const titleEl = document.getElementById('sovereignTitle');
        if (titleEl && titleConfig) {
            const l1 = titleEl.querySelector('.sovereign-title-line1');
            const l2 = titleEl.querySelector('.sovereign-title-line2');
            if (l1 && titleConfig.line1) l1.textContent = titleConfig.line1;
            if (l2 && titleConfig.line2) l2.textContent = titleConfig.line2;
        }
        // Store hp bar class for use in reveal step
        const _hpBarClass = (titleConfig && titleConfig.hpBarClass) ? titleConfig.hpBarClass : 'sovereign-hp-bar';

        if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});

        const dark    = document.getElementById('sovereignDark');
        const rainEl  = document.getElementById('sovereignRain');
        const flash   = document.getElementById('sovereignFlash');
        const title   = document.getElementById('sovereignTitle');
        const ripple  = document.getElementById('sovereignRipple');
        const hud     = document.getElementById('hud');
        const content = document.querySelector('.arena-content');
        const enemyEl = document.getElementById('enemySprite');

        // Boss sprite starts as silhouette; HUD hidden until reveal
        if (enemyEl) enemyEl.classList.add('sovereign-boss-shadow');
        if (hud)     hud.style.visibility = 'hidden';

        // ── 0ms: Darken + vignette + drone ─────────
        if (dark) dark.classList.add('active');
        startDrone();

        // ── 600ms: Rain ────────────────────────────
        setTimeout(() => {
            if (rainEl) rainEl.classList.add('active');
            _rainController = initRain();
        }, 600);

        // ── 1800ms: Lightning + thunder ────────────
        setTimeout(() => {
            if (_rainController) _rainController.setIntensity(2.2);
            const bg = document.getElementById('arenaBg');
            if (bg) { bg.style.transition = 'filter 0.04s'; bg.style.filter = 'brightness(2.5) saturate(0.3)'; }
            if (flash) { flash.classList.add('sovereign-flash-anim'); flash.style.opacity = '1'; }
            playThunder();
            setTimeout(() => {
                if (bg)    { bg.style.filter = ''; bg.style.transition = ''; }
                if (flash) { flash.style.opacity = '0'; }
            }, 130);
            setTimeout(() => { if (_rainController) _rainController.setIntensity(1.0); }, 350);
        }, 1800);

        // ── 2100ms: Camera shake ────────────────────
        setTimeout(() => {
            if (content) {
                content.classList.add('sovereign-shake');
                content.addEventListener('animationend', () => content.classList.remove('sovereign-shake'), { once: true });
            }
        }, 2100);

        // ── 2200ms: Boss reveal + HUD + particles ──
        setTimeout(() => {
            if (hud) hud.style.visibility = 'visible';
            if (enemyEl) {
                enemyEl.classList.remove('sovereign-boss-shadow');
                enemyEl.classList.add('sovereign-boss-reveal');
                enemyEl.addEventListener('animationend', () => {
                    enemyEl.classList.remove('sovereign-boss-reveal');
                    // Tint enemy HP bar (class varies by mode)
                    if (hud) {
                        const hpBar = hud.querySelector('.hud-side.right .hp-bar');
                        if (hpBar) hpBar.classList.add(_hpBarClass);
                    }
                }, { once: true });
            }
            spawnImpact();
        }, 2200);

        // ── 2400ms: Title in ───────────────────────
        setTimeout(() => { if (title) title.classList.add('active'); }, 2400);

        // ── 2550ms: RGB glitch flicker ─────────────
        setTimeout(() => {
            if (title) {
                title.classList.add('sovereign-title-glitch');
                setTimeout(() => title.classList.remove('sovereign-title-glitch'), 450);
            }
        }, 2550);

        // ── 2800ms: Rain dims + drone fades ────────
        setTimeout(() => {
            if (_rainController) _rainController.setIntensity(0.25);
            fadeDrone(500);
        }, 2800);

        // ── 2900ms: Title fades out ─────────────────
        setTimeout(() => {
            if (title) { title.style.transition = 'opacity 0.45s ease'; title.classList.remove('active'); }
        }, 2900);

        // ── 3300ms: Cleanup, ripple, complete ───────
        setTimeout(() => {
            if (dark) { dark.style.transition = 'opacity 0.3s ease'; dark.classList.remove('active'); }
            if (ripple) {
                ripple.classList.add('sovereign-ripple-anim');
                ripple.addEventListener('animationend', () => ripple.classList.remove('sovereign-ripple-anim'), { once: true });
            }
            setTimeout(() => {
                _cleanup();
                onComplete();
            }, 130);
        }, 3300);
    }

    function _cleanup() {
        if (_rainController) { _rainController.stop(); _rainController = null; }
        const enemyEl = document.getElementById('enemySprite');
        const content = document.querySelector('.arena-content');
        const hud     = document.getElementById('hud');
        if (enemyEl) enemyEl.classList.remove('sovereign-boss-shadow','sovereign-boss-reveal');
        if (content) content.classList.remove('sovereign-shake');
        if (hud)     { hud.classList.remove('sovereign-hud-dim'); hud.style.visibility = 'visible'; }
        const bg = document.getElementById('arenaBg');
        if (bg) { bg.style.filter = ''; bg.style.transition = ''; }
        ['sovereignDark','sovereignFlash','sovereignTitle','sovereignRain','sovereignRipple'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('active','sovereign-flash-anim','sovereign-ripple-anim','sovereign-title-glitch');
            el.style.opacity    = '';
            el.style.transition = '';
        });
    }

    function resetForNewRun() { _hasPlayed = false; }
    return { play, resetForNewRun };
})();

// ============================================================
// v14: COLISEUM CROWD REACTION SYSTEM
// Triggers ONLY on MELTDOWN. Never on Overheat, never on wins.
// Deep, layered, primal Roman-coliseum audio texture.
// ============================================================
const ColiseumCrowd = (() => {

    // ── MP3 crowd audio (primary carrier) ────────────────────
    // GitHub file attachment — direct download URL
    const _cheerAudio = new Audio('https://github.com/user-attachments/files/25475772/Crowd.Cheering.Final.mp3');
    _cheerAudio.preload = 'auto';
    _cheerAudio.volume  = 0.0; // controlled per-call

    // ── Internal state ────────────────────────────────────────
    let _lastCheerTime = 0; // prevent double-fire within same tick

    // ── Synthesised coliseum roar (runs alongside MP3) ────────
    // Low-frequency filtered noise burst: 0.8–1.2s, heavy body, echo tail
    function _synthesizeRoar(volumeScale, addReverb) {
        try {
            const ctx   = audioCtx;
            const t     = ctx.currentTime;
            const dur   = 0.85 + Math.random() * 0.35; // 0.85–1.2s

            // ── Layer 1: deep crowd mass — low-pass noise ────
            const bufLen1 = Math.floor(ctx.sampleRate * (dur + 0.3));
            const buf1    = ctx.createBuffer(1, bufLen1, ctx.sampleRate);
            const d1      = buf1.getChannelData(0);
            for (let i = 0; i < bufLen1; i++) {
                // Slow attack (first 80ms), sustain, tail
                const env = Math.min(i / (ctx.sampleRate * 0.08), 1) *
                            Math.exp(-Math.max(0, i - ctx.sampleRate * dur) / (ctx.sampleRate * 0.28));
                d1[i] = (Math.random() * 2 - 1) * env * 0.7;
            }
            const src1 = ctx.createBufferSource(); src1.buffer = buf1;
            const lp1  = ctx.createBiquadFilter(); lp1.type = 'lowpass'; lp1.frequency.value = 320; lp1.Q.value = 0.8;
            const lp2  = ctx.createBiquadFilter(); lp2.type = 'lowpass'; lp2.frequency.value = 180; lp2.Q.value = 0.5;
            const g1   = ctx.createGain(); g1.gain.value = 0.55 * volumeScale;
            src1.connect(lp1); lp1.connect(lp2); lp2.connect(g1); g1.connect(ctx.destination);
            src1.start(t);

            // ── Layer 2: mid crowd chatter — bandpass noise ──
            const bufLen2 = Math.floor(ctx.sampleRate * dur);
            const buf2    = ctx.createBuffer(1, bufLen2, ctx.sampleRate);
            const d2      = buf2.getChannelData(0);
            for (let i = 0; i < bufLen2; i++) {
                const env = Math.min(i / (ctx.sampleRate * 0.12), 1) *
                            Math.exp(-Math.max(0, i - ctx.sampleRate * (dur * 0.6)) / (ctx.sampleRate * 0.22));
                d2[i] = (Math.random() * 2 - 1) * env;
            }
            const src2 = ctx.createBufferSource(); src2.buffer = buf2;
            const bp1  = ctx.createBiquadFilter(); bp1.type = 'bandpass'; bp1.frequency.value = 600; bp1.Q.value = 0.6;
            const g2   = ctx.createGain(); g2.gain.value = 0.28 * volumeScale;
            src2.connect(bp1); bp1.connect(g2); g2.connect(ctx.destination);
            src2.start(t);

            // ── Layer 3: echo tail — delayed low repeat ──────
            const echoDelay = ctx.createDelay(1.0); echoDelay.delayTime.value = 0.38;
            const echoFb    = ctx.createGain(); echoFb.gain.value = 0.22;
            const echoOut   = ctx.createGain(); echoOut.gain.value = 0.18 * volumeScale;
            g1.connect(echoDelay); echoDelay.connect(echoFb); echoFb.connect(echoDelay);
            echoDelay.connect(echoOut); echoOut.connect(ctx.destination);

            // ── Layer 4 (boss only): convolution reverb tail ─
            if (addReverb) {
                const revLen = Math.floor(ctx.sampleRate * 1.4);
                const revBuf = ctx.createBuffer(2, revLen, ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const rd = revBuf.getChannelData(ch);
                    for (let i = 0; i < revLen; i++) {
                        rd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / revLen, 2.2) * 0.6;
                    }
                }
                const conv  = ctx.createConvolver(); conv.buffer = revBuf;
                const revG  = ctx.createGain(); revG.gain.value = 0.25 * volumeScale;
                g1.connect(conv); conv.connect(revG); revG.connect(ctx.destination);
            }
        } catch(e) {}
    }

    // ── Play MP3 crowd cheer at given volume ──────────────────
    function _playMP3(vol) {
        try {
            _cheerAudio.currentTime = 0;
            _cheerAudio.volume = Math.min(1, Math.max(0, vol));
            _cheerAudio.play().catch(() => {});
        } catch(e) {}
    }

    // ── Subtle crowd gasp (player meltdown) ──────────────────
    function _playGasp() {
        try {
            const ctx = audioCtx;
            const t   = ctx.currentTime;
            // Very quiet: short inhale-shaped noise, high-passed
            const bufLen = Math.floor(ctx.sampleRate * 0.35);
            const buf    = ctx.createBuffer(1, bufLen, ctx.sampleRate);
            const d      = buf.getChannelData(0);
            for (let i = 0; i < bufLen; i++) {
                const env = Math.min(i / (ctx.sampleRate * 0.05), 1) *
                            Math.exp(-i / (ctx.sampleRate * 0.18));
                d[i] = (Math.random() * 2 - 1) * env * 0.4;
            }
            const src = ctx.createBufferSource(); src.buffer = buf;
            const hp  = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 1200;
            const g   = ctx.createGain(); g.gain.value = 0.09; // very subtle
            src.connect(hp); hp.connect(g); g.connect(ctx.destination);
            src.start(t);
        } catch(e) {}
    }

    // ── Dust particle burst on arena floor ───────────────────
    function _spawnDust(intensity) {
        const canvas = document.getElementById('crowdDustCanvas');
        if (!canvas) return;
        const W = canvas.width  = canvas.offsetWidth  || 800;
        const H = canvas.height = canvas.offsetHeight || 200;
        canvas.classList.add('active');
        const ctx2 = canvas.getContext('2d');
        ctx2.clearRect(0, 0, W, H);

        const count = Math.floor(8 + intensity * 6); // 8–14 particles
        const particles = [];
        for (let i = 0; i < count; i++) {
            particles.push({
                x: W * (0.2 + Math.random() * 0.6),   // central spread
                y: H * 0.95,                            // floor level
                vx: (Math.random() - 0.5) * 3.5 * intensity,
                vy: -(1.5 + Math.random() * 3) * intensity,
                r:  1.5 + Math.random() * 3,
                life: 1,
                decay: 0.022 + Math.random() * 0.018,
                // sandy/dusty colours: tans, ochres, faint crimson mix
                hue: Math.random() < 0.75 ? `rgba(200,170,120,` : `rgba(160,60,60,`,
            });
        }

        let frame;
        function draw() {
            ctx2.clearRect(0, 0, W, H);
            let alive = false;
            particles.forEach(p => {
                p.x  += p.vx; p.y += p.vy;
                p.vy += 0.12; // gravity
                p.vx *= 0.96;
                p.life -= p.decay;
                if (p.life <= 0) return;
                alive = true;
                ctx2.beginPath();
                ctx2.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx2.fillStyle = `${p.hue}${(p.life * 0.65).toFixed(2)})`;
                ctx2.fill();
            });
            if (alive) {
                frame = requestAnimationFrame(draw);
            } else {
                ctx2.clearRect(0, 0, W, H);
                canvas.classList.remove('active');
            }
        }
        frame = requestAnimationFrame(draw);
        // Safety cleanup
        setTimeout(() => { cancelAnimationFrame(frame); ctx2.clearRect(0, 0, W, H); canvas.classList.remove('active'); }, 900);
    }

    // ── Ambient reverb boost flash on arena-bg ────────────────
    function _reverbBoost() {
        const bg = document.getElementById('arenaBg');
        if (!bg) return;
        bg.classList.add('crowd-reverb-flash');
        bg.addEventListener('animationend', () => bg.classList.remove('crowd-reverb-flash'), { once: true });
    }

    // ── Very subtle ground vibration (no horizontal shake) ───
    function _vibrate() {
        const content = document.querySelector('.arena-content');
        if (!content) return;
        content.classList.add('crowd-vibrate');
        content.addEventListener('animationend', () => content.classList.remove('crowd-vibrate'), { once: true });
    }

    // ── Boss camera pulse (50ms, Hard Mode meltdown only) ────
    function _bossCameraPulse() {
        const screen = document.querySelector('.arena-screen');
        if (!screen) return;
        screen.style.transition = 'transform 0.05s ease-out';
        screen.style.transform  = 'scale(1.008)';
        setTimeout(() => {
            screen.style.transform  = 'scale(1)';
            setTimeout(() => { screen.style.transition = ''; }, 60);
        }, 50);
    }

    // ── Display coliseum crowd text line in crowdReactEl ─────
    function _showCrowdText(isBoss) {
        const el = document.getElementById('crowdReactEl');
        if (!el) return;
        const lines = isBoss
            ? [' ▶▶ THE CROWD ERUPTS ◀◀ ', ' ⚔ COLISEUM ROARS ⚔ ', ' ▶ BLOOD FOR THE ARENA ◀ ']
            : [' ▶ MELTDOWN ◀ ', '  THE CROWD ROARS  ', ' ▶ CARNAGE ◀ '];
        el.textContent = lines[Math.floor(Math.random() * lines.length)];
        el.style.color      = isBoss ? '#ff2244' : '#ffaa00';
        el.style.textShadow = isBoss ? '0 0 12px #cc0022' : '0 0 8px #ff8800';
        el.style.opacity    = '1';
        el.style.fontSize   = isBoss ? '16px' : '13px';
        setTimeout(() => {
            el.style.opacity    = '0';
            el.style.color      = '';
            el.style.textShadow = '';
            el.style.fontSize   = '';
        }, isBoss ? 2200 : 1800);
    }

    // ── Main entry point — called from checkOverheat ──────────
    function onMeltdown(who) {
        // Debounce: don't double-fire within same clock tick
        const now = Date.now();
        if (now - _lastCheerTime < 100) return;

        const fightNum    = run.wins + 1;
        const isHardBoss  = saveData.settings.hardModeEnabled && fightNum === 24;
        const isEnemy     = (who === 'enemy');

        if (!isEnemy) {
            // Player meltdown — optional very subtle gasp only
            _playGasp();
            return;
        }

        // Enemy meltdown path
        if (isHardBoss) {
            // Hard Mode final boss — always triggers, +20% volume, reverb, camera pulse
            _lastCheerTime = now;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
            _synthesizeRoar(1.2, true);   // +20% volume + reverb tail
            _playMP3(0.72);               // MP3 at boosted volume
            _showCrowdText(true);
            _spawnDust(1.4);              // bigger dust burst
            _vibrate();
            _reverbBoost();
            _bossCameraPulse();
            // Do NOT increment crowdCheerCount beyond cap
            run.crowdCheerCount = Math.min(run.crowdCheerCount, run.crowdCheerMax);
        } else {
            // Standard enemy meltdown — 80% chance, max 2 per run
            if (run.crowdCheerCount >= run.crowdCheerMax) return;
            if (Math.random() > 0.80) return; // 20% chance to stay silent — keep it rare
            _lastCheerTime = now;
            run.crowdCheerCount++;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
            _synthesizeRoar(1.0, false);
            _playMP3(0.55);
            _showCrowdText(false);
            _spawnDust(1.0);
            _vibrate();
            _reverbBoost();
        }
    }

    return { onMeltdown };
})();

// ============================================================
// RUN MANAGEMENT
// ============================================================
function startRun(fighterId) {
    SovereignEntrance.resetForNewRun(); // v9: allow entrance sequence to play once per run
    const base = ALL_FIGHTERS.find(f => f.id === fighterId);
    // Build enemy queue: all other fighters, shuffled
    // v7: Exclude Character 7 from random pool — reserved as the fight-24 Adaptive Boss
    const enemies = ALL_FIGHTERS.filter(f => f.id !== fighterId && f.id !== 7);
    shuffleArray(enemies);

    run = {
        player: newFighterState({ ...base }),
        enemies: enemies,
        enemyIndex: 0,
        wins: 0,
        upgrades: [],
        clashNum: 0,
        playerStanceHistory: [],
        cumulativeStanceTotals: { rush: 0, counter: 0, zone: 0 },
        crowdCheerCount: 0,   // v14: Coliseum crowd — cheers fired this run
        crowdCheerMax: 2,     // v14: max cheers per run
    };
    startFight();
}

function startFight() {
    const baseEnemy = run.enemies[run.enemyIndex];
    const fightNum = run.wins + 1; // 1-indexed

    // Apply enemy scaling based on fight tier — tighter progression
    const scaledEnemy = { ...baseEnemy };
    if (fightNum >= 6 && fightNum < 12) {
        scaledEnemy.baseHp = baseEnemy.baseHp + 1;
    } else if (fightNum >= 12 && fightNum < 18) {
        scaledEnemy.baseHp = baseEnemy.baseHp + 2;
        if (fightNum % 2 === 0) {
            scaledEnemy.guard = Math.min(4, baseEnemy.guard + 1);
        } else {
            scaledEnemy.power = Math.min(5, baseEnemy.power + 1);
        }
    } else if (fightNum >= 18) {
        scaledEnemy.baseHp = baseEnemy.baseHp + 3;
        scaledEnemy.power = Math.min(5, baseEnemy.power + 1);
    }

    // Late-game HP scaling — separate bonus stacked on top of tier scaling.
    // Normal: heavier scaling to counter player MaxHP snowball.
    // Hard: lighter scaling to preserve brutal-but-fair feel.
    if (saveData.settings.hardModeEnabled) {
        if (fightNum >= 12 && fightNum < 18) scaledEnemy.baseHp += 1;  // Hard fights 12–17: +1 HP
        else if (fightNum >= 18)             scaledEnemy.baseHp += 3;  // Hard fights 18–23: +3 HP
    } else {
        if (fightNum >= 12 && fightNum < 18) scaledEnemy.baseHp += 2;  // Normal fights 12–17: +2 HP
        else if (fightNum >= 18)             scaledEnemy.baseHp += 4;  // Normal fights 18–23: +4 HP
    }

    // Normal Mode only: late-game Guard scaling — anti-snowball measure.
    // High-maxHP players deal less effective damage in late fights.
    // Hard Mode is exempt (enemy difficulty already tuned separately).
    if (!saveData.settings.hardModeEnabled) {
        if (fightNum >= 12 && fightNum < 18) {
            scaledEnemy.guard = Math.min(6, scaledEnemy.guard + 1);  // fights 12–17: +1 Guard
        } else if (fightNum >= 18) {
            scaledEnemy.guard = Math.min(6, scaledEnemy.guard + 2);  // fights 18–23: +2 Guard
        }
    }

    // CHANGE v3: Early Assassin variant — reduce Speed 4→3 in fights 1–3 only.
    // Prevents first-strike + katana bonus coinflip before player has any upgrades.
    // From fight 4 onward, Assassin uses full base Speed 4.
    if (fightNum <= 3 && scaledEnemy.archetype === 'assassin') {
        scaledEnemy.speed = Math.min(scaledEnemy.speed, 3);
    }

    // Hard Mode: early enemy softening — fights 1–5 enemies have -1 Power.
    // Gives players time to accumulate upgrades before full enemy stats kick in.
    if (saveData.settings.hardModeEnabled && fightNum <= 5) {
        scaledEnemy.power = Math.max(1, scaledEnemy.power - 1);
    }

    // -- v7: Normal Adaptive Boss -- Fight 24 only --
    // Normal mode final fight: force Character 7 as boss with overridden stats
    // and adaptive stance bias derived from player's cumulative stance history.
    // Character 7 is excluded from the random enemy pool, so fight 24 is always the boss.
    let bossIntroLines = null;
    if (!saveData.settings.hardModeEnabled && fightNum === 24) {
        const char7Base = ALL_FIGHTERS.find(f => f.id === 7);
        if (char7Base) {
            // Re-apply Character 7 identity over whatever enemy was in slot 23
            scaledEnemy.id        = char7Base.id;
            scaledEnemy.archetype = char7Base.archetype;
            scaledEnemy.weapon    = char7Base.weapon;
            scaledEnemy.trait     = char7Base.trait;
            // Stat override BEFORE tier scaling: base is HP=11, P=4, S=4, G=3.
            // Existing tier logic (fight>=18) already added: +3 HP (tier), +1 Power (tier),
            // +4 HP (Normal late bonus), +2 Guard (Normal late guard, capped 6).
            // We reconstruct the final scaled result explicitly from our base values:
            scaledEnemy.baseHp = 11 + 3 + 4;   // base + tier HP + Normal late HP = 18
            scaledEnemy.power  = Math.min(5, 4 + 1); // base + tier Power
            scaledEnemy.speed  = 4;
            scaledEnemy.guard  = Math.min(6, 3 + 2); // base + Normal late guard
            // Boss display name
            scaledEnemy.name = 'Citizen #0007 — Arena Sovereign';
            // Compute adaptive stance bias from cumulative run stance totals
            const totals = run.cumulativeStanceTotals || { rush: 0, counter: 0, zone: 0 };
            const mostUsed = Object.keys(totals).reduce((a, b) => totals[a] >= totals[b] ? a : b);
            // Counter-stance map: boss biases toward what beats player's most-used stance
            // Rush beats Zone; Counter beats Rush; Zone beats Counter
            const adaptiveCounterMap = { rush: 'zone', counter: 'rush', zone: 'counter' };
            scaledEnemy._adaptiveBiasStance = adaptiveCounterMap[mostUsed] || 'zone';
            scaledEnemy._adaptiveBiasAmount = 0.25;
            bossIntroLines = [
                'Analysis complete.',
                'Pattern recognition: predictable.'
            ];
        }
    }

    // -- v10: Hard Mode Final Boss — UAEC Sovereign Frame -- Fight 24 only --
    // Hard Mode final fight: fully synthetic boss (id 99), gun fighter.
    // Base stats HP=14, P=5, S=4, G=4 — existing Hard Mode tier scaling applied on top.
    // Attack kit: Railburst Cannon, Suppression Barrage, Reactive Plating, Overclock Protocol.
    // No new systems introduced — all abilities expressed via existing stat/stability fields.
    let hardBossTitleConfig = null;
    if (saveData.settings.hardModeEnabled && fightNum === 24) {
        // Hard Mode tier scaling for fight >= 18: +3 HP (already applied above), +1 Power (already applied).
        // We set final explicit values starting from our designed base, then add Hard Mode late-HP (+3).
        scaledEnemy.id        = 99;           // synthetic final boss ID
        scaledEnemy.archetype = 'elite_duelist'; // stance pattern: counter-heavy
        scaledEnemy.weapon    = 'gun';
        scaledEnemy.trait     = null;
        scaledEnemy.name      = 'UAEC Sovereign Frame';
        // Base: HP=14, P=5, S=4, G=4 — apply existing Hard Mode fight-18+ scaling explicitly:
        //   Tier HP: +3 (fight>=18), Hard late HP: +3 (fight>=18)  → 14+3+3 = 20
        //   Tier Power: +1 capped at 5 → already 5, no change
        scaledEnemy.baseHp = 14 + 3 + 3;     // 20
        scaledEnemy.power  = 5;               // already at cap, tier +1 absorbed
        scaledEnemy.speed  = 4;
        scaledEnemy.guard  = Math.min(6, 4);  // 4 — Hard Mode doesn't add late guard
        // Boss-specific ability state flags (reset each fight via newFighterState spread)
        scaledEnemy._sf_guardBonusNext  = 0;  // Reactive Plating: +guard for next clash
        scaledEnemy._sf_powerBonusNext  = 0;  // Overclock Protocol: +power for next clash
        scaledEnemy._sf_currentPose     = null;
        scaledEnemy._sf_attackPose      = null;
        // Stance bias: elite_duelist — counter-heavy with balanced zone fallback
        // (inherits from ARCHETYPES.elite_duelist: rush:1 counter:2 zone:1)
        bossIntroLines = [
            'UAEC Sovereign Frame — online.',
            'Execution protocol: initiated.'
        ];
        hardBossTitleConfig = {
            line1: 'UAEC SOVEREIGN FRAME',
            line2: 'EXECUTION PROTOCOL INITIATED',
            hpBarClass: 'sovereign-hp-bar-hard',
        };
    }

    // -- v8: Mid-Late Pressure Scaling (Normal Mode only) --
    // Stacks on top of all existing scaling (tier, late-HP, late-guard) and the boss override.
    // Fights  9–16: +1 Guard (cap 6)
    // Fights 17+:   +1 Guard (cap 6), +1 Power (no extra cap)
    // Hard Mode is untouched. Speed and stability rules unchanged.
    if (!saveData.settings.hardModeEnabled) {
        if (fightNum >= 9 && fightNum <= 16) {
            scaledEnemy.guard = Math.min(6, scaledEnemy.guard + 1);  // v8 mid pressure: +1 Guard
        } else if (fightNum >= 17) {
            scaledEnemy.guard = Math.min(6, scaledEnemy.guard + 1);  // v8 late pressure: +1 Guard
            scaledEnemy.power = scaledEnemy.power + 1;               // v8 late pressure: +1 Power
        }
    }

    run.currentEnemy = newFighterState(scaledEnemy);
    run.clashNum = 0;
    run.playerStanceHistory = [];
    run._firstClashSparkFired = false; // v11: reset per-fight spark flag
    // Reset player stability between fights (but keep permanent flags like neuralOverclocked)
    // Hard Mode: player starts each fight with 1 stability instead of 0
    run.player.stability = (saveData.settings.hardModeEnabled) ? 1 : 0;
    run.player.overheatActive = false;
    run.player.meltdownActive = false;
    run.player.dangerWindow = 0;
    run.player._shockUsed = false; // Reset Shock Absorbers each fight

    document.getElementById('runInfo').textContent = `Fight ${fightNum} / ${run.enemies.length}${saveData.settings.hardModeEnabled ? ' · HARD' : ''}`;
    showScreen('arenaScreen');
    renderArena();
    ArenaFX.enable(saveData.arena && saveData.arena.upgradeUnlocked && saveData.arena.upgradeEnabled);
    document.querySelectorAll('.fighter-sprite').forEach(el => PrestigeSystem.applyGlowToEl(el));

    // v9/v10: Entrance Sequence — fight 24 only, both modes
    const isBossFight24 = (fightNum === 24);
    const isNormalBoss = (!saveData.settings.hardModeEnabled && isBossFight24);
    const isHardBoss   = (saveData.settings.hardModeEnabled  && isBossFight24);

    if (isNormalBoss || isHardBoss) {
        enableStanceButtons(false); // input locked until sequence ends
        SovereignEntrance.play(() => {
            if (bossIntroLines && bossIntroLines.length) {
                let delay = 0;
                bossIntroLines.forEach(line => {
                    setTimeout(() => logClash(line, 'boss-intro'), delay);
                    delay += 700;
                });
                setTimeout(() => enableStanceButtons(true), delay + 150);
            } else {
                enableStanceButtons(true);
            }
        }, isHardBoss ? hardBossTitleConfig : null);
    } else {
        // Standard fights — enable immediately, then log any intro lines
        enableStanceButtons(true);
        if (bossIntroLines && bossIntroLines.length) {
            enableStanceButtons(false);
            let delay = 200;
            bossIntroLines.forEach(line => {
                setTimeout(() => logClash(line, 'boss-intro'), delay);
                delay += 800;
            });
            setTimeout(() => enableStanceButtons(true), delay + 200);
        }
    }
}

// ============================================================
// ARENA RENDERING
// ============================================================
function renderArena() {
    const p = run.player;
    const e = run.currentEnemy;
    const pArch = ARCHETYPES[p.archetype];
    const eArch = ARCHETYPES[e.archetype];

    // HUD
    document.getElementById('hud').innerHTML = `
        <div class="hud-side">
            <div class="hud-name">${p.name}</div>
            <div class="hud-archetype">${pArch.name} · ${p.weapon.toUpperCase()}</div>
            <div class="hud-stats">
                <div><span class="stat-label">HP</span> <div class="hp-bar">${hpPips(p.hp, p.maxHp, false)}</div></div>
            </div>
            <div class="hud-stats">
                <div><span class="stat-label">STB</span> <div class="stability-bar">${stabPips(p.stability, true)}</div></div>
                <div><span class="stat-label">PWR ${p.power}</span></div>
                <div><span class="stat-label">SPD ${p.speed}</span></div>
                <div><span class="stat-label">GRD ${p.guard}</span></div>
            </div>
        </div>
        <div class="hud-center">
            <div class="clash-num">${run.clashNum > 0 ? 'Clash ' + run.clashNum : 'FIGHT!'}</div>
            <div class="fight-label">Fight ${run.wins + 1}</div>
        </div>
        <div class="hud-side right">
            <div class="hud-name enemy">${e.name}</div>
            <div class="hud-archetype">${eArch.name} · ${e.weapon.toUpperCase()}</div>
            <div class="hud-stats">
                <div><div class="hp-bar">${hpPips(e.hp, e.maxHp, true)}</div> <span class="stat-label">HP</span></div>
            </div>
            <div class="hud-stats">
                <div><div class="stability-bar">${stabPips(e.stability, false)}</div> <span class="stat-label">STB</span></div>
                <div><span class="stat-label">PWR ${e.power}</span></div>
                <div><span class="stat-label">SPD ${e.speed}</span></div>
                <div><span class="stat-label">GRD ${e.guard}</span></div>
            </div>
        </div>
    `;

    // Fighters
    renderFighterSprites(p, e);
}

function hpPips(current, max, isEnemy) {
    let s = '';
    for (let i = 0; i < max; i++) {
        const cls = isEnemy ? 'hp-pip enemy' : 'hp-pip';
        s += `<div class="${cls}${i >= current ? ' empty' : ''}"></div>`;
    }
    return s;
}

function stabPips(val, isPlayer) {
    // v11: Hard-cleared players get crimson stability bar — cosmetic only
    const useCrimson = isPlayer && saveData.meta && saveData.meta.hardModeCleared;
    let s = '';
    for (let i = 0; i < 5; i++) {
        const isEmpty = i >= val;
        const isFilled = !isEmpty;
        let cls = 'stab-pip';
        if (isEmpty) {
            cls += ' empty';
        } else if (useCrimson) {
            cls += ' prestige-crimson';
            if (val >= 4) cls += ' pulsing'; // animate at high stability
        }
        s += `<div class="${cls}"></div>`;
    }
    return s;
}

function getPose(fighter) {
    if (fighter.hp <= 0) return 'death';
    // v10: UAEC Sovereign Frame — contextual sprite state (checked before generic meltdown)
    // Boss has no dysentery_death; meltdown maps to overheated for visual consistency.
    if (fighter.id === 99) {
        if (fighter.meltdownActive || fighter.overheatActive) return 'overheated';
        if (fighter._sf_currentPose) return fighter._sf_currentPose;
        const injuredThreshold = Math.ceil(fighter.maxHp * 0.4);
        if (fighter.hp <= injuredThreshold) return 'injured';
        return 'idle';
    }
    if (fighter.meltdownActive) return 'dysentery_death';
    if (fighter.overheatActive) return 'overheated';
    return fighter.weapon;  // gun or katana idle
}

function getAttackPose(fighter) {
    // v10: Final boss uses railburst_cannon as default attack pose
    if (fighter.id === 99) return fighter._sf_attackPose || 'railburst_cannon';
    return fighter.weapon === 'gun' ? 'gun_attack' : 'katana_attack';
}

function renderFighterSprites(p, e) {
    const pPose = getPose(p);
    const ePose = getPose(e);
    const pStatus = getStatusBadge(p);
    const eStatus = getStatusBadge(e);
    const enemySpriteClass = e.id === 99 ? 'fighter-sprite right final-boss-sprite' : 'fighter-sprite right';

    document.getElementById('fightersArea').innerHTML = `
        <div class="fighter-slot">
            <div class="fighter-sprite" id="playerSprite">
                ${pStatus}
                <img src="${spriteUrl(p.id, pPose)}" onerror="this.style.display='none'">
            </div>
        </div>
        <div class="fighter-slot">
            <div class="${enemySpriteClass}" id="enemySprite">
                ${eStatus}
                <img src="${spriteUrl(e.id, ePose)}" onerror="this.style.display='none'">
            </div>
        </div>
    `;
}

function getStatusBadge(fighter) {
    if (fighter.meltdownActive) return '<div class="status-badge meltdown">MELTDOWN</div>';
    if (fighter.overheatActive) return '<div class="status-badge overheat">OVERHEAT</div>';
    if (fighter.dangerWindow > 0) return '<div class="status-badge danger">DANGER</div>';
    return '';
}

// ============================================================
// STANCE SYSTEM & CLASH RESOLUTION
// ============================================================
const STANCE_TRIANGLE = { rush: 'zone', counter: 'rush', zone: 'counter' };
// rush beats zone, counter beats rush, zone beats counter

function stanceResult(attacker, defender) {
    if (STANCE_TRIANGLE[attacker] === defender) return 'advantage';
    if (STANCE_TRIANGLE[defender] === attacker) return 'disadvantage';
    return 'neutral';
}

function enableStanceButtons(enabled) {
    const panel = document.getElementById('stancePanel');
    if (enabled) {
        panel.innerHTML = `
            <div class="stance-prompt">Choose your stance:</div>
            <div class="stance-buttons">
                <button class="stance-btn rush" onclick="playerChooseStance('rush')">Rush</button>
                <button class="stance-btn counter" onclick="playerChooseStance('counter')">Counter</button>
                <button class="stance-btn zone" onclick="playerChooseStance('zone')">Zone</button>
            </div>
        `;
    } else {
        panel.innerHTML = `<div class="stance-prompt" style="color: #444;">Resolving...</div>`;
    }
}

window.playerChooseStance = function(stance) {
    enableStanceButtons(false);
    const enemyStance = chooseEnemyStance(run.currentEnemy, run.playerStanceHistory, run.player);
    run.playerStanceHistory.push(stance);
    if (run.cumulativeStanceTotals) run.cumulativeStanceTotals[stance]++;
    run.clashNum++;
    resolveClash(stance, enemyStance);
};

// ============================================================
// AI: ENEMY STANCE CHOICE
// ============================================================
function chooseEnemyStance(enemy, playerHistory, player) {
    const arch = ARCHETYPES[enemy.archetype];
    const weights = { rush: 1 + arch.stanceBias.rush, counter: 1 + arch.stanceBias.counter, zone: 1 + arch.stanceBias.zone };

    // v7: Adaptive Boss bias — applied only at fight 24 Normal mode, set once at fight start.
    // Adds +0.25 normalized bias toward the counter of the player's most-used stance.
    if (enemy._adaptiveBiasStance && enemy._adaptiveBiasAmount) {
        // Convert raw weights to proportional, apply bias, cap at 0.65, renormalize.
        let total = weights.rush + weights.counter + weights.zone;
        const props = { rush: weights.rush / total, counter: weights.counter / total, zone: weights.zone / total };
        props[enemy._adaptiveBiasStance] = Math.min(0.65, props[enemy._adaptiveBiasStance] + enemy._adaptiveBiasAmount);
        // Renormalize so props sum to 1
        const propTotal = props.rush + props.counter + props.zone;
        props.rush    /= propTotal;
        props.counter /= propTotal;
        props.zone    /= propTotal;
        // Write back as raw weights (scale by 100 for precision)
        weights.rush    = props.rush    * 100;
        weights.counter = props.counter * 100;
        weights.zone    = props.zone    * 100;
    }

    // Fight tier determines AI aggressiveness
    const fightNum = run.wins + 1; // 1-indexed current fight
    const isLateFight = fightNum >= 16;
    const isMidFight  = fightNum >= 8;

    // Pattern adaptation — scale with fight tier
    if (playerHistory.length >= 2) {
        const recent = playerHistory.slice(-3);
        const counts = { rush: 0, counter: 0, zone: 0 };
        recent.forEach(s => counts[s]++);
        const mostUsed = Object.keys(counts).reduce((a, b) => counts[a] >= counts[b] ? a : b);
        const counterTo = Object.keys(STANCE_TRIANGLE).find(k => STANCE_TRIANGLE[k] === mostUsed);
        if (counterTo) {
            // Late fights punish patterns harder
            weights[counterTo] += isLateFight ? 4 : isMidFight ? 3 : 2;
        }
    }

    // Late fights: actively exploit high player stability
    if (isLateFight && player.stability >= 3) {
        // Push the stance that gives them advantage (forces player to take more damage or overheat)
        // Rush beats Zone, Counter beats Rush, Zone beats Counter
        // We want to pick the stance that beats what forces player into disadvantage
        weights.rush   += 1;
        weights.counter += 1;
        weights.zone   += 1;
        // Specifically: if player stability is high, enemy favors the stance that beats player's archetype bias
        const playerArch = ARCHETYPES[player.archetype];
        const playerFavored = Object.keys(playerArch.stanceBias).reduce((a, b) => playerArch.stanceBias[a] >= playerArch.stanceBias[b] ? a : b);
        const beatsPlayer = Object.keys(STANCE_TRIANGLE).find(k => STANCE_TRIANGLE[k] === playerFavored);
        if (beatsPlayer) weights[beatsPlayer] += 2;
    }

    // Low HP → more aggressive (rush)
    if (enemy.hp <= Math.ceil(enemy.maxHp / 3)) weights.rush += 2;

    // High stability → prefer counter (costs -1 stability, smart self-management)
    if (enemy.stability >= 4) weights.counter += 3;

    // Trickster: chaotic randomness
    if (enemy.archetype === 'trickster') {
        weights.rush    += Math.random() * (isLateFight ? 2 : 3);
        weights.counter += Math.random() * (isLateFight ? 2 : 3);
        weights.zone    += Math.random() * (isLateFight ? 2 : 3);
    }

    // Weighted random
    const total = weights.rush + weights.counter + weights.zone;
    let r = Math.random() * total;
    if (r < weights.rush) return 'rush';
    r -= weights.rush;
    if (r < weights.counter) return 'counter';
    return 'zone';
}

// ============================================================
// CLASH RESOLUTION
// ============================================================
function resolveClash(playerStance, enemyStance) {
    const p = run.player;
    const e = run.currentEnemy;

    // -- v11: First Clash Spark Effect --
    // If player has Hard Mode cleared, fire a micro lightning spark + sound on clash 1 only.
    // Once per fight, purely cosmetic, no camera shake, no gameplay effect.
    if (run.clashNum === 1 && saveData.meta && saveData.meta.hardModeCleared && !run._firstClashSparkFired) {
        run._firstClashSparkFired = true;
        PrestigeSystem.fireFirstClashSpark();
    }

    // Determine stance results
    const pResult = stanceResult(playerStance, enemyStance);
    const eResult = stanceResult(enemyStance, playerStance);

    // v10: Track boss stance result for post-clash Suppression Barrage trigger
    if (e.id === 99) e._sf_lastStanceResult = eResult;

    // Stability changes from stance
    addStability(p, 1, 'attacking');
    addStability(e, 1, 'attacking');
    // Neural Upgrade drawback: +1 extra stability per Neural taken when attacking
    if (p.neuralOverclocked) addStability(p, p.neuralOverclocked, 'neural surcharge');
    if (e.neuralOverclocked) addStability(e, e.neuralOverclocked, 'neural surcharge');
    if (pResult === 'advantage') { addStability(p, 1, 'stance advantage'); ArenaFX.crowdReact('light'); }
    if (eResult === 'advantage') { addStability(e, 1, 'stance advantage'); ArenaFX.crowdReact('light'); }
    if (playerStance === 'rush' && p.weapon === 'katana') addStability(p, 1, 'katana rush');
    if (enemyStance === 'rush' && e.weapon === 'katana') addStability(e, 1, 'katana rush');
    if (playerStance === 'counter') addStability(p, -1, 'counter stance');
    if (enemyStance === 'counter') addStability(e, -1, 'counter stance');
    // Hard Mode: enemies gain +1 stability each clash (more overheat pressure on player)
    if (saveData.settings.hardModeEnabled) addStability(e, 1, 'hard mode pressure');
    // Hard Mode: +1 extra stability on Rush stance (increases overheat risk for aggressive play)
    if (saveData.settings.hardModeEnabled) {
        if (playerStance === 'rush') addStability(p, 1, 'hard mode rush surge');
        if (enemyStance  === 'rush') addStability(e, 1, 'hard mode rush surge');
    }

    // Set feedback loop guard flag for this clash (clash-scoped, cleared after)
    p._feedbackGuardActive = (p.trait === 'stability_feedback_loop' && pResult === 'advantage');
    e._feedbackGuardActive = (e.trait === 'stability_feedback_loop' && eResult === 'advantage');

    // -- v10: UAEC Sovereign Frame ability PRE-PROCESSING --
    // Apply queued per-clash buffs from previous clash abilities before damage calc.
    // Overclock Protocol (+power), Reactive Plating (+guard) are applied here then cleared.
    let _sfOrigGuard = null, _sfOrigPower = null;
    if (e.id === 99) {
        // Overclock Protocol: if Stability ≥ 4 at start of clash, +1 Power this clash + self +1 Stability
        if (e.stability >= 4 && !e.overheatActive) {
            e._sf_powerBonusNext = (e._sf_powerBonusNext || 0) + 1;
            addStability(e, 1, 'overclock self-risk');
            e._sf_currentPose = e.overheatActive ? 'overheated' : 'railburst_cannon'; // switches to OH if now at 5
        }
        // Apply queued buffs
        if (e._sf_guardBonusNext) {
            _sfOrigGuard = e.guard;
            e.guard = Math.min(6, e.guard + e._sf_guardBonusNext);
            e._sf_currentPose = 'reactive_plating';
        }
        if (e._sf_powerBonusNext) {
            _sfOrigPower = e.power;
            e.power = e.power + e._sf_powerBonusNext;
        }
        // Reset queued buffs — consumed this clash
        e._sf_guardBonusNext = 0;
        e._sf_powerBonusNext = 0;
    }

    // -- v10: Apply player guard penalty from last clash Suppression Barrage --
    let _sfPlayerGuardPenalty = 0;
    if (p._sf_guardPenaltyNext) {
        _sfPlayerGuardPenalty = p._sf_guardPenaltyNext;
        p._sf_guardPenaltyNext = 0;
    }
    // Temporarily reduce player guard for damage calc
    const _sfOrigPlayerGuard = p.guard;
    if (_sfPlayerGuardPenalty > 0) p.guard = Math.max(0, p.guard - _sfPlayerGuardPenalty);

    // Calculate damage
    let pDmg = calcDamage(p, e, pResult, playerStance);
    let eDmg = calcDamage(e, p, eResult, enemyStance);

    // Restore stat temporaries after damage calc
    if (_sfOrigGuard !== null) e.guard = _sfOrigGuard;
    if (_sfOrigPower !== null) e.power = _sfOrigPower;
    if (_sfPlayerGuardPenalty > 0) {
        p.guard = _sfOrigPlayerGuard;
        if (_sfPlayerGuardPenalty > 0) logClash(`Suppression Barrage: your guard reduced this clash!`, 'disadvantage');
    }

    // Clear feedback flags after damage calc
    p._feedbackGuardActive = false;
    e._feedbackGuardActive = false;

    // Apply archetype bonuses
    pDmg = applyArchetypeBonus(p, e, pDmg, pResult, run.clashNum);
    eDmg = applyArchetypeBonus(e, p, eDmg, eResult, run.clashNum);

    // -- v10: Railburst Cannon bonus damage (UAEC boss stance advantage) --
    // +1 damage if boss has stance advantage (stacks after archetype bonus)
    if (e.id === 99 && eResult === 'advantage') {
        eDmg += 1;
        e._sf_attackPose = 'railburst_cannon';
        e._sf_currentPose = null; // let getAttackPose handle during animation
    } else if (e.id === 99) {
        e._sf_attackPose = 'railburst_cannon'; // default attack pose
    }

    // v10: Track boss outgoing damage for Railburst Cannon stability trigger in postClash
    if (e.id === 99) e._sf_lastDmgDealt = eDmg;

    // Overheat penalties
    if (p.overheatActive) { pDmg = Math.max(1, pDmg - 1); }
    if (e.overheatActive) { eDmg = Math.max(1, eDmg - 1); }

    // Speed determines who hits first — hard cap at 4
    let pSpeed = p.overheatActive ? 0 : Math.min(p.speed, 4);
    let eSpeed = e.overheatActive ? 0 : Math.min(e.speed, 4);

    // Log stance choices
    logClash(`You: ${playerStance.toUpperCase()} vs Enemy: ${enemyStance.toUpperCase()}`, pResult);

    // Resolve hits in speed order
    const pFirst = pSpeed >= eSpeed;

    // Animation sequence
    setTimeout(() => {
        if (pFirst) {
            animateAttack('player', p, pDmg, () => {
                applyDamage(e, pDmg, 'enemy');
                if (e.hp > 0) {
                    setTimeout(() => {
                        animateAttack('enemy', e, eDmg, () => {
                            applyDamage(p, eDmg, 'player');
                            postClash(playerStance, enemyStance);
                        });
                    }, 400);
                } else {
                    postClash(playerStance, enemyStance);
                }
            });
        } else {
            animateAttack('enemy', e, eDmg, () => {
                applyDamage(p, eDmg, 'player');
                if (p.hp > 0) {
                    setTimeout(() => {
                        animateAttack('player', p, pDmg, () => {
                            applyDamage(e, pDmg, 'enemy');
                            postClash(playerStance, enemyStance);
                        });
                    }, 400);
                } else {
                    postClash(playerStance, enemyStance);
                }
            });
        }
    }, 300);
}

function calcDamage(attacker, defender, stanceResult, stance) {
    let stanceBonus = 0;
    if (stanceResult === 'advantage' && !attacker.overheatActive) {
        // v17: Unified Advantage Amplification
        // Normal ≥ fight 9 → +3. Hard ≥ fight 17 → +3. Fights 1–8 both modes → +2.
        const _fn = run.wins + 1;
        const _amplify = saveData.settings.hardModeEnabled ? (_fn >= 17) : (_fn >= 9);
        stanceBonus = _amplify ? 3 : 2;
    }
    else if (stanceResult === 'disadvantage') stanceBonus = -1;

    // Stability Feedback Loop (Char 7): stance advantage → -1 Stability, +1 Guard this clash
    let feedbackGuardBonus = 0;
    if (attacker.trait === 'stability_feedback_loop' && stanceResult === 'advantage') {
        addStability(attacker, -1, 'feedback loop');
        feedbackGuardBonus = 1; // attacker gets +1 guard for this clash (not used for outgoing dmg, handled below)
    }
    if (defender.trait === 'stability_feedback_loop' && stanceResult === 'disadvantage') {
        // defender won stance advantage in their perspective — handled when calcDamage is called for defender
    }

    let weaponBonus = 0;
    let defGuard = attacker.overheatActive ? 0 : defender.guard;
    // Apply feedback loop guard bonus to defender if they triggered it
    if (defender.trait === 'stability_feedback_loop' && defender._feedbackGuardActive) {
        defGuard += 1;
    }
    if (attacker.weapon === 'gun') defGuard = Math.max(0, defGuard - 1);

    // Speed soft cap at 4 — excess speed does NOT increase katana bonus further
    const effectiveAttSpeed = Math.min(attacker.speed, 4);
    const effectiveDefSpeed = Math.min(defender.speed, 4);
    // Katana bonus requires speed advantage of at least 1 (no stacking burst from equal speed)
    if (attacker.weapon === 'katana' && (effectiveAttSpeed - effectiveDefSpeed) >= 1) weaponBonus = 1;

    return Math.max(1, attacker.power + stanceBonus + weaponBonus - defGuard);
}

function applyArchetypeBonus(fighter, opponent, dmg, stanceResult, clashNum) {
    const a = fighter.archetype;
    if (a === 'duelist' && stanceResult === 'neutral') dmg += 1;
    if (a === 'glasscannon' && clashNum === 1) dmg += 2;
    if (a === 'assassin' && stanceResult === 'advantage') dmg += 1;
    // Berserker low-HP bonus: Normal Mode triggers at ≤1/4 max HP (tighter window vs Hard Mode's ≤1/3).
    // Prevents late-game runaway when max HP is inflated by upgrades.
    const berserkThresh = saveData.settings.hardModeEnabled
        ? Math.ceil(fighter.maxHp / 3)   // Hard Mode: original threshold
        : Math.ceil(fighter.maxHp / 4);  // Normal Mode: tighter threshold
    if (a === 'berserker' && fighter.hp <= berserkThresh) dmg += 2;
    return dmg;
}

function addStability(fighter, amount, reason) {
    fighter.stability = Math.max(0, Math.min(5, fighter.stability + amount));
}

function applyDamage(target, dmg, targetId) {
    // Juggernaut: reduce burst damage
    if (target.archetype === 'juggernaut' && dmg >= 4) dmg = Math.max(1, dmg - 1);
    // Shock Absorbers (Char 8): first damage instance each fight reduced by 1 (min 1)
    if (target.trait === 'shock_absorbers' && !target._shockUsed) {
        dmg = Math.max(1, dmg - 1);
        target._shockUsed = true;
    }

    // Heavy damage stability gain
    if (dmg >= 3) addStability(target, 1, 'heavy hit taken');

    target.hp = Math.max(0, target.hp - dmg);

    // v10: Track last damage taken by UAEC boss for Reactive Plating
    if (target.id === 99) target._sf_lastDmgTaken = (target._sf_lastDmgTaken || 0) + dmg;

    // Show damage popup
    const spriteEl = document.getElementById(targetId === 'player' ? 'playerSprite' : 'enemySprite');
    if (spriteEl) {
        spriteEl.classList.add('shake');
        const popup = document.createElement('div');
        popup.className = 'dmg-popup';
        popup.textContent = `-${dmg}`;
        spriteEl.appendChild(popup);
        setTimeout(() => { spriteEl.classList.remove('shake'); popup.remove(); }, 1000);
    }
}

function animateAttack(who, fighter, dmg, callback) {
    const spriteEl = document.getElementById(who === 'player' ? 'playerSprite' : 'enemySprite');
    if (!spriteEl) { callback(); return; }

    // Show attack pose
    const attackPose = getAttackPose(fighter);
    const img = spriteEl.querySelector('img');
    if (img) img.src = spriteUrl(fighter.id, attackPose);

    // Play sound
    playSound(fighter.weapon === 'gun' ? 'laser' : 'sword');

    // Gun: show muzzle flash + bullet trail
    if (fighter.weapon === 'gun') {
        const side = who === 'player' ? 'player-side' : 'enemy-side';

        // Muzzle flash (SVG starburst)
        const flash = document.createElement('div');
        flash.className = `muzzle-flash ${side}`;
        flash.innerHTML = `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
            <polygon points="30,2 33,26 50,10 34,28 58,30 34,32 50,50 33,34 30,58 27,34 10,50 26,32 2,30 26,28 10,10 27,26"
                fill="#ffe066" opacity="0.95"/>
            <circle cx="30" cy="30" r="8" fill="#fff" opacity="0.9"/>
        </svg>`;
        spriteEl.appendChild(flash);

        // Bullet trail
        const trail = document.createElement('div');
        trail.className = `bullet-trail ${side}`;
        spriteEl.appendChild(trail);

        setTimeout(() => {
            flash.remove();
            trail.remove();
        }, 220);
    }

    setTimeout(() => {
        // Return to idle pose
        if (img) img.src = spriteUrl(fighter.id, getPose(fighter));
        callback();
    }, 350);
}

// ============================================================
// POST-CLASH: OVERHEAT / MELTDOWN / WIN/LOSS CHECK
// ============================================================
function postClash(playerStance, enemyStance) {
    const p = run.player;
    const e = run.currentEnemy;

    // Tick danger windows
    if (p.dangerWindow > 0) p.dangerWindow--;
    if (e.dangerWindow > 0) e.dangerWindow--;

    // Clear overheat flags from previous clash
    p.overheatActive = false;
    e.overheatActive = false;
    p.meltdownActive = false;
    e.meltdownActive = false;

    // Check overheat triggers
    checkOverheat(p, 'player');
    checkOverheat(e, 'enemy');

    // -- v10: UAEC Sovereign Frame POST-CLASH ability processing --
    // After damage is dealt and overheat checked, evaluate triggered abilities for NEXT clash.
    if (e.id === 99 && e.hp > 0) {
        const lastEDmg = e._sf_lastDmgTaken || 0;
        const lastEStanceResult = e._sf_lastStanceResult || 'neutral';
        const lastEDmgDealt = e._sf_lastDmgDealt || 0;

        // 1) Railburst Cannon: if boss dealt ≥ 4 total damage this clash → player +1 Stability
        if (lastEDmgDealt >= 4 && p.hp > 0) {
            addStability(p, 1, 'railburst destabilize');
            logClash(`Railburst Cannon: concussion wave — your stability surges!`, 'disadvantage');
        }

        // 2) Suppression Barrage: on stance WIN by boss (eResult === 'advantage') → player Guard -1 next clash
        if (lastEStanceResult === 'advantage') {
            p._sf_guardPenaltyNext = (p._sf_guardPenaltyNext || 0) + 1;
            e._sf_currentPose = 'suppression_barrage';
            logClash(`Suppression Barrage: your guard suppressed next clash!`, 'disadvantage');
        }

        // 3) Reactive Plating: if boss took burst ≥ 4 this clash → +1 Guard next clash (cap 6)
        if (lastEDmg >= 4) {
            e._sf_guardBonusNext = (e._sf_guardBonusNext || 0) + 1;
            e._sf_currentPose = 'reactive_plating';
            logClash(`Reactive Plating: Sovereign Frame hardens!`, 'overheat');
        }

        // Reset pose back to idle/injured after logging
        if (e._sf_currentPose === 'suppression_barrage' || e._sf_currentPose === 'reactive_plating') {
            setTimeout(() => {
                if (e._sf_currentPose === 'suppression_barrage' || e._sf_currentPose === 'reactive_plating') {
                    e._sf_currentPose = null;
                    renderArena();
                }
            }, 500);
        }

        // Clear per-clash tracking
        e._sf_lastDmgTaken    = 0;
        e._sf_lastDmgDealt    = 0;
        e._sf_lastStanceResult = 'neutral';
    }

    // Update HUD
    renderArena();

    // Check win/loss
    if (e.hp <= 0) {
        logClash(`${e.name} DEFEATED!`, 'kill');
        playSound('thud');
        ArenaFX.crowdReact('roar');
        setTimeout(() => fightWon(), 1500);
        return;
    }
    if (p.hp <= 0) {
        logClash(`${p.name} has fallen!`, 'kill');
        playSound('thud');
        setTimeout(() => gameOver(), 1500);
        return;
    }

    // Next clash
    setTimeout(() => enableStanceButtons(true), 600);
}

function checkOverheat(fighter, who) {
    if (fighter.stability >= 5) {
        if (fighter.dangerWindow > 0) {
            // MELTDOWN
            fighter.meltdownActive = true;
            fighter.hp = Math.max(0, fighter.hp - 2);
            fighter.stability = 2;
            fighter.dangerWindow = 0;
            logClash(`${fighter.name} MELTDOWN! Takes 2 true damage!`, 'meltdown');
            playSound('fart');
            // v14: Coliseum crowd reaction — meltdown only, never overheat
            ColiseumCrowd.onMeltdown(who);
        } else {
            // OVERHEAT — crowd does NOT react here
            fighter.overheatActive = true;
            fighter.stability = 3;
            fighter.dangerWindow = 2;
            logClash(`${fighter.name} OVERHEATED! Weakened next clash.`, 'overheat');
            playSound('sparks');
            ArenaFX.crowdReact('cheer');
        }
    }
}

// ============================================================
// CLASH LOG
// ============================================================
function logUpgradeOverflow(statName, upgradeName) {
    // Called when a stat cap is hit — overflow becomes MaxHP
    const log = document.getElementById('clashLog');
    if (!log) return;
    const entry = document.createElement('div');
    entry.className = 'log-entry overheat-log';
    entry.textContent = `⚡ ${statName} cap reached! ${upgradeName} converted to +1 MaxHP`;
    log.appendChild(entry);
}

function logClash(text, type) {
    const log = document.getElementById('clashLog');
    const entry = document.createElement('div');
    let cls = 'log-entry';
    if (type === 'advantage') cls += ' advantage';
    else if (type === 'disadvantage') cls += ' disadvantage';
    else if (type === 'overheat') cls += ' overheat-log';
    else if (type === 'meltdown') cls += ' meltdown-log';
    else if (type === 'kill') cls += ' kill';
    else if (type === 'boss-intro') cls += ' boss-intro';
    entry.className = cls;
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

// ============================================================
// FIGHT WON → UPGRADE
// ============================================================
function fightWon() {
    run.wins++;
    const fightJustWon = run.wins; // 1-indexed fight number just completed

    // ── Milestone: Fight 8 ──────────────────────────────────
    if (fightJustWon === 8 && !saveData.meta.milestones.beat8) {
        saveData.meta.milestones.beat8 = true;
        if (!saveData.meta.unlockedCharacters.includes(8)) saveData.meta.unlockedCharacters.push(8);
        SaveManager.save(saveData);
        showMilestoneToast('⚡ New Fighter Unlocked: Character 8 — Gun Juggernaut!');
    }

    // ── Milestone: Fight 16 ─────────────────────────────────
    if (fightJustWon === 16 && !saveData.meta.milestones.beat16) {
        saveData.meta.milestones.beat16 = true;
        saveData.arena.upgradeUnlocked = true;
        saveData.arena.upgradeEnabled = true;
        SaveManager.save(saveData);
        showMilestoneToast('🌆 Arena Upgrade Unlocked! Toggle it in settings.');
        ArenaFX.refreshToggleUI();
    }

    if (run.enemyIndex >= run.enemies.length - 1) {
        // Beat everyone!
        // v11: Hard Mode final boss defeat → play cinematic before normal gameOver
        if (saveData.settings.hardModeEnabled) {
            hardClearCinematic(() => gameOver(true));
        } else {
            gameOver(true);
        }
        return;
    }
    run.enemyIndex++;
    // Post-fight heal — Normal: +3 HP. Hard Mode: conditional +1 or +2.
    if (saveData.settings.hardModeEnabled) {
        const missing = run.player.maxHp - run.player.hp;
        const hardHeal = (missing >= 5) ? 2 : 1;
        run.player.hp = Math.min(run.player.maxHp, run.player.hp + hardHeal);
    } else {
        run.player.hp = Math.min(run.player.maxHp, run.player.hp + 3);
    }
    showUpgradeScreen();
}

// ── Milestone toast ─────────────────────────────────────────
function showMilestoneToast(msg) {
    let toast = document.getElementById('milestoneToast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'milestoneToast';
        toast.style.cssText = `
            position:fixed;bottom:30px;left:50%;transform:translateX(-50%);
            background:rgba(0,0,0,0.92);border:2px solid #ffaa00;color:#ffaa00;
            font-family:'Courier New',monospace;font-size:15px;font-weight:bold;
            padding:14px 28px;z-index:9999;letter-spacing:1px;
            box-shadow:0 0 20px rgba(255,170,0,0.5);text-align:center;
            opacity:0;transition:opacity 0.4s;pointer-events:none;
        `;
        document.body.appendChild(toast);
    }
    toast.textContent = msg;
    toast.style.opacity = '1';
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { toast.style.opacity = '0'; }, 4000);
}

function showUpgradeScreen() {
    document.getElementById('upgradeSubtitle').textContent =
        `${run.wins} win${run.wins !== 1 ? 's' : ''} — HP: ${run.player.hp}/${run.player.maxHp}`;

    const upgrades = generateUpgrades();
    const container = document.getElementById('upgradeCards');
    container.innerHTML = '';

    upgrades.forEach(u => {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        const catLabel = u.cat === 'heal' ? '💊 UTILITY' : '⚡ STAT';
        const isNeural = u.name === 'Neural Upgrade';
        card.innerHTML = `
            <div style="font-size:11px;color:#666;letter-spacing:1px;margin-bottom:6px;">${catLabel}</div>
            <h3>${u.name}</h3>
            <p>${u.desc}</p>
            ${isNeural ? '<p style="color:#ff6600;font-size:12px;margin-top:6px;">⚠ Increases overheat risk</p>' : ''}
        `;
        card.addEventListener('click', () => {
            u.apply(run.player);
            run.upgrades.push(u.name);
            startFight();
        });
        container.appendChild(card);
    });

    showScreen('upgradeScreen');
}

// ============================================================
// STAT CAP OVERFLOW CONVERSION
// Power cap: 8 | Guard cap: 6 | Speed cap: 5
// Overflow converts to +1 MaxHP and +1 heal
// ============================================================
const STAT_CAPS = { power: 8, guard: 6, speed: 5 };

function applyStatOrOverflow(p, stat, amount) {
    // amount is always 1 for all current upgrades
    const cap = STAT_CAPS[stat];
    if (p[stat] < cap) {
        p[stat] += amount;
    } else {
        // Convert to MaxHP bonus
        p.maxHp++;
        p.baseHp++;
        p.hp = Math.min(p.maxHp, p.hp + 1);
        return true; // overflowed
    }
    return false;
}

function generateUpgrades() {
    const p = run.player;
    const hpRatio = p.hp / p.maxHp;

    // Define card categories
    const healCards = [
        { w: 5, cat: 'heal', name: 'Repair Nanites',   desc: 'Restore 3 HP',            apply: p => { p.hp = Math.min(p.maxHp, p.hp + 3); } },
        { w: 4, cat: 'heal', name: 'Armor Plating',    desc: '+1 Max HP, restore 1 HP', apply: p => { p.maxHp++; p.baseHp++; p.hp = Math.min(p.maxHp, p.hp + 1); } },
        { w: 4, cat: 'heal', name: 'Reinforced Frame', desc: '+2 Max HP',               apply: p => { p.maxHp += 2; p.baseHp += 2; } },
    ];

    // Full Restore only appears if HP ≤ 60% AND not in Hard Mode
    if (hpRatio <= 0.6 && !saveData.settings.hardModeEnabled) {
        healCards.push({ w: 1, cat: 'heal', name: 'Full Restore', desc: 'Restore to max HP', apply: p => { p.hp = p.maxHp; } });
    }

    const statCards = [
        { w: 4, cat: 'stat', name: 'Overclock',
          desc: `+1 Power (cap: ${STAT_CAPS.power})`,
          apply: p => { const ov = applyStatOrOverflow(p, 'power', 1); if (ov) logUpgradeOverflow('Power', 'Overclock'); } },
        { w: 3, cat: 'stat', name: 'Reflex Boost',
          desc: `+1 Speed (cap: ${STAT_CAPS.speed})`,
          apply: p => { const ov = applyStatOrOverflow(p, 'speed', 1); if (ov) logUpgradeOverflow('Speed', 'Reflex Boost'); } },
        { w: 5, cat: 'stat', name: 'Shield Module',
          desc: `+1 Guard (cap: ${STAT_CAPS.guard})`,
          apply: p => { const ov = applyStatOrOverflow(p, 'guard', 1); if (ov) logUpgradeOverflow('Guard', 'Shield Module'); } },
        { w: 1, cat: 'stat', name: 'Neural Upgrade',
          desc: `+1 Power & +1 Speed · Drawback: +1 Stability/attack`,
          apply: p => {
              const povOv = applyStatOrOverflow(p, 'power', 1);
              const sovOv = applyStatOrOverflow(p, 'speed', 1);
              p.neuralOverclocked = (p.neuralOverclocked || 0) + 1;
              if (povOv) logUpgradeOverflow('Power', 'Neural Upgrade');
              if (sovOv) logUpgradeOverflow('Speed', 'Neural Upgrade');
          }
        },
    ];

    function pickWeighted(arr) {
        const total = arr.reduce((s, c) => s + c.w, 0);
        let r = Math.random() * total;
        for (const c of arr) { r -= c.w; if (r < 0) return c; }
        return arr[arr.length - 1];
    }

    const chosen = [];
    const usedNames = new Set();

    // Slot 1: healing/utility
    const healPool = healCards.filter(c => !usedNames.has(c.name));
    const healPick = pickWeighted(healPool);
    chosen.push(healPick);
    usedNames.add(healPick.name);

    // Slot 2: permanent stat — only ONE stat card per screen
    const statPool = statCards.filter(c => !usedNames.has(c.name));
    const statPick = pickWeighted(statPool);
    chosen.push(statPick);
    usedNames.add(statPick.name);

    // Slot 3: wildcard — omitted in Hard Mode (only 2 choices)
    if (!saveData.settings.hardModeEnabled) {
        const wildcardPool = [...healCards, ...statCards].filter(c => !usedNames.has(c.name));
        if (wildcardPool.length > 0) {
            const wildcardPick = pickWeighted(wildcardPool);
            chosen.push(wildcardPick);
        }
    }

    return chosen;
}

// ============================================================
// v11: HARD CLEAR VICTORY CINEMATIC
// Sequence: audio cut → rain surge → glitch ripple → text in
// → sub-bass heartbeat → fade to black → onComplete()
// Pure presentation. No stat effects.
// ============================================================
function hardClearCinematic(onComplete) {
    const cinEl   = document.getElementById('hardClearCinematic');
    const textEl  = document.getElementById('hardClearText');
    const fadeEl  = document.getElementById('hardClearFade');
    const rainEl  = document.getElementById('sovereignRain');
    const ripple  = document.getElementById('sovereignRipple');
    if (!cinEl) { onComplete(); return; }

    cinEl.classList.add('active');

    // ── 0ms: Cut arena audio (mute background music briefly) ──
    const prevVol = bgMusic.volume;
    bgMusic.volume = 0;

    // ── 0ms: Intensify rain if visible ────────────────────────
    if (rainEl) {
        rainEl.style.transition = 'opacity 0.2s';
        rainEl.style.opacity    = '0.85';
    }

    // ── 300ms: Glitch ripple (300ms) ──────────────────────────
    setTimeout(() => {
        if (ripple) {
            ripple.classList.add('sovereign-ripple-anim');
            ripple.addEventListener('animationend', () => ripple.classList.remove('sovereign-ripple-anim'), { once: true });
        }
    }, 300);

    // ── 600ms: Text fades in ──────────────────────────────────
    setTimeout(() => {
        if (textEl) textEl.classList.add('visible');
    }, 600);

    // ── 700ms: Sub-bass heartbeat hit ─────────────────────────
    setTimeout(() => {
        try {
            const ctx = audioCtx;
            if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            const t = ctx.currentTime;
            // Deep impact pulse
            const o = ctx.createOscillator();
            o.type = 'sine'; o.frequency.setValueAtTime(55, t); o.frequency.exponentialRampToValueAtTime(28, t + 0.4);
            const g = ctx.createGain();
            g.gain.setValueAtTime(1.0, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
            o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.5);
            // Short sub-click layer
            const o2 = ctx.createOscillator();
            o2.type = 'square'; o2.frequency.value = 80;
            const g2 = ctx.createGain();
            g2.gain.setValueAtTime(0.3, t); g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            o2.connect(g2); g2.connect(ctx.destination); o2.start(t); o2.stop(t + 0.1);
        } catch(e) {}
    }, 700);

    // ── 1800ms: Fade audio back in, rain dims ─────────────────
    setTimeout(() => {
        bgMusic.volume = prevVol;
        if (rainEl) { rainEl.style.opacity = '0'; setTimeout(() => { rainEl.style.opacity = ''; rainEl.style.transition = ''; }, 600); }
    }, 1800);

    // ── 2200ms: Fade to black ─────────────────────────────────
    setTimeout(() => {
        if (textEl)  textEl.classList.remove('visible');
        if (fadeEl)  fadeEl.classList.add('active');
    }, 2200);

    // ── 3100ms: Complete — clean up and proceed to gameOver ───
    setTimeout(() => {
        // Reset cinematic elements
        if (fadeEl)  { fadeEl.classList.remove('active'); }
        if (cinEl)   { cinEl.classList.remove('active'); }
        if (textEl)  { textEl.classList.remove('visible'); }
        onComplete();
    }, 3100);
}

// ============================================================
// GAME OVER
// ============================================================
function gameOver(victory) {
    const title = document.getElementById('gameoverTitle');
    const stats = document.getElementById('finalStats');

    if (victory) {
        title.textContent = 'CHAMPION';
        title.style.color = '#00ff66';
    } else {
        title.textContent = 'DEFEATED';
        title.style.color = '#ff0000';
    }

    const fightReached = run.wins + (victory ? 0 : 1);
    stats.innerHTML = `
        <div>Wins: ${run.wins} / ${run.enemies.length}</div>
        <div>Fighter: ${run.player.name}</div>
        <div>Archetype: ${ARCHETYPES[run.player.archetype].name}</div>
        <div>Upgrades: ${run.upgrades.length > 0 ? run.upgrades.join(', ') : 'None'}</div>
    `;

    // ── First-clear / Fight-23 milestone unlock ────────────
    const isFirstClear = victory && !saveData.meta.milestones.fullClear;
    if (isFirstClear) {
        saveData.meta.milestones.fullClear  = true;
        saveData.meta.hasClearedOnce        = true;
        saveData.meta.hardModeUnlocked      = true;
        saveData.cosmetics.goldGlowUnlocked = true;
        saveData.cosmetics.badgeUnlocked    = true;
        if (!saveData.meta.unlockedCharacters.includes(7)) saveData.meta.unlockedCharacters.push(7);
        SaveManager.save(saveData);
        setTimeout(() => showUnlockBanner(), 300);
    }

    // ── v11/v15: Hard Mode clear — runs every time, not just first ─
    if (victory && saveData.settings.hardModeEnabled) {
        const isFirstHardClear = !saveData.meta.hardModeCleared;
        // Always record the fighter used (if not already in list)
        if (!saveData.meta.hardClearFighterIds) saveData.meta.hardClearFighterIds = [];
        if (!saveData.meta.hardClearFighterIds.includes(run.player.id)) {
            saveData.meta.hardClearFighterIds.push(run.player.id);
        }
        if (isFirstHardClear) {
            saveData.meta.hardModeCleared       = true;
            saveData.meta.hardClearFighterId    = run.player.id;   // v13: legacy single-id field
            saveData.cosmetics.hardBadgeUnlocked = true;
            setTimeout(() => showMilestoneToast('⚔ HARD MODE CLEARED — Sovereign Frame Defeated ⚔'), 400);
        } else {
            // Subsequent clears with new fighters — quiet acknowledgement
            setTimeout(() => showMilestoneToast(`⭐ ${run.player.name} added to Hard Mode clears`), 400);
        }
        SaveManager.save(saveData);
    }

    // ── Persist run results ──────────────────────────────────
    saveAfterRun(fightReached, victory);

    // Auto-unlock: grant the selected fighter permanently
    unlockCharacter(run.player.id);

    // Meta currency: 1 per win, bonus 5 for full clear
    const currencyEarned = run.wins + (victory ? 5 : 0);
    if (currencyEarned > 0) earnMetaCurrency(currencyEarned);

    // ── Show lifetime stats on game over screen ──────────────
    const metaEl = document.getElementById('metaStatsDisplay');
    if (metaEl) {
        const isNewBest = fightReached >= saveData.meta.bestFightReached;
        metaEl.innerHTML = `
            <div class="meta-stat-box">
                <div class="msb-val">${saveData.meta.totalRuns}</div>
                <div class="msb-label">Total Runs</div>
            </div>
            <div class="meta-stat-box">
                <div class="msb-val">${saveData.meta.bestFightReached}</div>
                <div class="msb-label">Best Fight${isNewBest && fightReached > 1 ? ' 🏆' : ''}</div>
            </div>
            <div class="meta-stat-box">
                <div class="msb-val">${saveData.meta.totalWins}</div>
                <div class="msb-label">Total Wins</div>
            </div>
            <div class="meta-stat-box">
                <div class="msb-val">${saveData.meta.metaCurrency}</div>
                <div class="msb-label">Credits</div>
            </div>
        `;
    }

    // Show victory badge if unlocked
    refreshBadgeVisibility();

    showScreen('gameoverScreen');
}

// ============================================================
// UTILITY
// ============================================================
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}


// ============================================================
// SAVE MANAGER
// Stores all persistent data under one localStorage key.
// Version field enables safe future migrations.
// ============================================================
const SaveManager = (() => {
    const SAVE_KEY = 'arenaSave';
    const CURRENT_VERSION = 5;

    const DEFAULT_SAVE = {
        version: CURRENT_VERSION,
        meta: {
            totalRuns: 0,
            bestFightReached: 0,
            totalWins: 0,
            unlockedCharacters: [],
            metaCurrency: 0,
            hardModeUnlocked: false,
            hasClearedOnce: false,
            hardModeCleared: false,       // v11: set on first Hard Mode full clear
            hardClearFighterId: null,     // v13: id of fighter used to clear Hard Mode (first clear only)
            hardClearFighterIds: [],      // v15: all fighters used to clear Hard Mode (cumulative)
            milestones: { beat8: false, beat16: false, fullClear: false },
        },
        cosmetics: {
            goldGlowUnlocked: false,
            badgeUnlocked: false,
            hardBadgeUnlocked: false,     // v11: Hard Mode clear badge (top-right title screen)
        },
        arena: {
            upgradeUnlocked: false,
            upgradeEnabled: true,
        },
        settings: {
            soundOn: true,
            musicOn: false,
            hardModeEnabled: false,
            prestigeGlowEnabled: false,
        },
    };

    // Deep clone so callers can't mutate the default
    function defaultSave() {
        return JSON.parse(JSON.stringify(DEFAULT_SAVE));
    }

    // ── Migrations ──────────────────────────────────────────
    // Add a new case here whenever CURRENT_VERSION increments.
    // Each migration receives the raw save object and returns
    // a patched version. Never delete existing cases.
    function migrateIfNeeded(save) {
        // v0 → v1: nothing existed before; shouldn't normally hit
        if (!save.version || save.version < 1) {
            console.warn('[SaveManager] Migrating save to v1');
            const fresh = defaultSave();
            // Preserve any fields that happen to overlap
            if (save.meta) Object.assign(fresh.meta, save.meta);
            if (save.settings) Object.assign(fresh.settings, save.settings);
            save = fresh;
        }
        // v1 -> v2: adds hardMode, hasClearedOnce, cosmetics block
        if (save.version < 2) {
            console.warn('[SaveManager] Migrating v1 -> v2');
            if (!save.meta.hasOwnProperty('hardModeUnlocked'))  save.meta.hardModeUnlocked = false;
            if (!save.meta.hasOwnProperty('hasClearedOnce'))    save.meta.hasClearedOnce   = false;
            if (!save.cosmetics) save.cosmetics = { goldGlowUnlocked: false, badgeUnlocked: false };
            if (!save.settings.hasOwnProperty('hardModeEnabled')) save.settings.hardModeEnabled = false;
            save.version = 2;
        }
        // v2 -> v3: adds milestones, arena block, prestigeGlowEnabled
        if (save.version < 3) {
            console.warn('[SaveManager] Migrating v2 -> v3');
            if (!save.meta.milestones) save.meta.milestones = { beat8: false, beat16: false, fullClear: false };
            if (!save.arena) save.arena = { upgradeUnlocked: false, upgradeEnabled: true };
            if (!save.settings.hasOwnProperty('prestigeGlowEnabled')) save.settings.prestigeGlowEnabled = false;
            save.version = 3;
        }
        // v3 -> v4: adds hardModeCleared flag and hardBadgeUnlocked cosmetic
        if (save.version < 4) {
            console.warn('[SaveManager] Migrating v3 -> v4');
            if (!save.meta.hasOwnProperty('hardModeCleared'))       save.meta.hardModeCleared = false;
            if (!save.meta.hasOwnProperty('hardClearFighterId'))    save.meta.hardClearFighterId = null;
            if (!save.cosmetics.hasOwnProperty('hardBadgeUnlocked')) save.cosmetics.hardBadgeUnlocked = false;
            save.version = 4;
        }
        // v4 -> v5: adds hardClearFighterIds array — seeds from legacy hardClearFighterId if present
        if (save.version < 5) {
            console.warn('[SaveManager] Migrating v4 -> v5');
            if (!save.meta.hasOwnProperty('hardClearFighterIds')) {
                const legacy = save.meta.hardClearFighterId;
                save.meta.hardClearFighterIds = (legacy != null) ? [legacy] : [];
            }
            save.version = 5;
        }
        return save;
    }

    // ── load ────────────────────────────────────────────────
    function load() {
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) {
                // First run — create and persist a fresh save
                const fresh = defaultSave();
                _write(fresh);
                return fresh;
            }
            let parsed = JSON.parse(raw);
            // Guard against corrupted objects
            if (typeof parsed !== 'object' || parsed === null) throw new Error('Invalid save shape');
            // Run version migrations
            parsed = migrateIfNeeded(parsed);
            // Persist migrated version immediately
            _write(parsed);
            return parsed;
        } catch (err) {
            console.error('[SaveManager] Load failed, resetting to default:', err);
            const fresh = defaultSave();
            _write(fresh);
            return fresh;
        }
    }

    // ── save ────────────────────────────────────────────────
    function save(data) {
        try {
            if (typeof data !== 'object' || data === null) throw new Error('save() requires an object');
            _write(data);
        } catch (err) {
            console.error('[SaveManager] Save failed:', err);
        }
    }

    // ── reset ────────────────────────────────────────────────
    function reset() {
        try {
            localStorage.removeItem(SAVE_KEY);
            const fresh = defaultSave();
            _write(fresh);
            return fresh;
        } catch (err) {
            console.error('[SaveManager] Reset failed:', err);
            return defaultSave();
        }
    }

    // ── private write ────────────────────────────────────────
    function _write(data) {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    }

    return { load, save, reset, migrateIfNeeded };
})();

// ============================================================
// GLOBAL SAVE STATE  (populated on load, mutated during play)
// ============================================================
let saveData = SaveManager.load();

// ── Helpers for common save operations ──────────────────────

function saveAfterRun(fightReached, didWin) {
    saveData.meta.totalRuns++;
    if (fightReached > saveData.meta.bestFightReached) {
        saveData.meta.bestFightReached = fightReached;
    }
    if (didWin) saveData.meta.totalWins++;
    SaveManager.save(saveData);
}

function unlockCharacter(charId) {
    if (!saveData.meta.unlockedCharacters.includes(charId)) {
        saveData.meta.unlockedCharacters.push(charId);
        SaveManager.save(saveData);
    }
}

function earnMetaCurrency(amount) {
    saveData.meta.metaCurrency += amount;
    SaveManager.save(saveData);
}

function updateSetting(key, value) {
    saveData.settings[key] = value;
    SaveManager.save(saveData);
}

// ── Sync music toggle with saved setting ─────────────────────
(function applySavedSettings() {
    const musicToggle = document.getElementById('musicToggle');
    if (musicToggle) {
        musicToggle.checked = saveData.settings.musicOn;
        if (saveData.settings.musicOn) bgMusic.play().catch(() => {});
    }
})();


// ============================================================
// ARENA FX SYSTEM
// Subtle neon pulse, spotlight sweep, crowd reactions.
// Only active when arena.upgradeUnlocked && arena.upgradeEnabled.
// ============================================================
const ArenaFX = (() => {
    let _enabled = false;
    let _spotlightTimer = null;
    let _crowdTimer = null;

    const CROWD_LINES = {
        light: ['  ooooh  ', '  aaaah  ', ' ▶ NICE ◀ '],
        cheer: [' ▶ OVERHEAT ◀ ', '  OOOOOH  ', ' CROWD GOES WILD '],
        roar:  [' ▶ FATALITY ◀ ', '  ROARS  ', ' ▶▶ FINISH ◀◀ '],
    };

    function isActive() {
        return _enabled && saveData.arena && saveData.arena.upgradeUnlocked && saveData.arena.upgradeEnabled;
    }

    function enable(on) {
        _enabled = on;
        const bg = document.getElementById('arenaBg');
        if (!bg) return;
        if (on && saveData.arena && saveData.arena.upgradeUnlocked) {
            bg.classList.add('arena-fx-pulse');
            startSpotlightLoop();
        } else {
            bg.classList.remove('arena-fx-pulse');
            stopSpotlightLoop();
        }
    }

    function startSpotlightLoop() {
        stopSpotlightLoop();
        function sweep() {
            if (!isActive()) return;
            const el = document.getElementById('arenaSpotlight');
            if (!el) return;
            el.style.left = '-120%';
            el.classList.add('active');
            let pos = -120;
            const interval = setInterval(() => {
                pos += 4;
                el.style.left = pos + '%';
                if (pos > 160) {
                    clearInterval(interval);
                    el.classList.remove('active');
                }
            }, 16);
            _spotlightTimer = setTimeout(sweep, 8000 + Math.random() * 6000);
        }
        _spotlightTimer = setTimeout(sweep, 3000 + Math.random() * 3000);
    }

    function stopSpotlightLoop() {
        clearTimeout(_spotlightTimer);
        const el = document.getElementById('arenaSpotlight');
        if (el) el.classList.remove('active');
    }

    function crowdReact(eventType) {
        if (!isActive()) return;
        const el = document.getElementById('crowdReactEl');
        if (!el) return;
        const lines = CROWD_LINES[eventType] || CROWD_LINES.light;
        el.textContent = lines[Math.floor(Math.random() * lines.length)];
        el.style.opacity = '1';
        clearTimeout(_crowdTimer);
        _crowdTimer = setTimeout(() => { el.style.opacity = '0'; }, 1800);
    }

    function refreshToggleUI() {
        const row = document.getElementById('arenaFxRow');
        if (!row) return;
        if (saveData.arena && saveData.arena.upgradeUnlocked) {
            row.classList.add('unlocked');
        } else {
            row.classList.remove('unlocked');
        }
        const tog = document.getElementById('arenaFxToggle');
        if (tog) tog.checked = saveData.arena ? saveData.arena.upgradeEnabled : false;
    }

    function wireEvents() {
        const tog = document.getElementById('arenaFxToggle');
        if (tog) {
            tog.addEventListener('change', e => {
                saveData.arena.upgradeEnabled = e.target.checked;
                SaveManager.save(saveData);
                enable(e.target.checked);
            });
        }
    }

    function init() {
        refreshToggleUI();
        wireEvents();
        if (saveData.arena && saveData.arena.upgradeUnlocked && saveData.arena.upgradeEnabled) {
            _enabled = true;
        }
    }

    return { init, enable, crowdReact, refreshToggleUI, isActive };
})();

// ============================================================
// PRESTIGE SYSTEM
// Handles: badge visibility, glow toggle, hard mode toggle,
//          unlock banner, and applying saved cosmetic settings.
// ============================================================
const PrestigeSystem = (() => {

    // ── Badge ──────────────────────────────────────────────
    function refreshBadgeVisibility() {
        // Normal clear badge — top-left
        const normalBadgeUnlocked = saveData.cosmetics && saveData.cosmetics.badgeUnlocked;
        const normalBadgeEl = document.getElementById('titleBadge');
        if (normalBadgeEl) normalBadgeEl.style.display = normalBadgeUnlocked ? 'inline-flex' : 'none';

        // v11: Hard Mode clear badge — top-right, title screen ONLY
        const hardBadgeUnlocked = saveData.cosmetics && saveData.cosmetics.hardBadgeUnlocked;
        const hardBadgeEl = document.getElementById('titleHardBadge');
        if (hardBadgeEl) {
            hardBadgeEl.style.display = hardBadgeUnlocked ? 'block' : 'none';
        }

        // v13: Fighter icon under hard badge — show the fighter used to clear Hard Mode
        const iconEl = document.getElementById('hardClearFighterIcon');
        if (iconEl && hardBadgeUnlocked) {
            const fighterId = saveData.meta && saveData.meta.hardClearFighterId;
            if (fighterId != null) {
                const fighter = ALL_FIGHTERS.find(f => f.id === fighterId);
                const pose = fighter ? fighter.weapon : 'gun';
                const name = fighter ? fighter.name : '';
                const shortName = name.replace('Citizen ', '').replace('Character ', '#');
                iconEl.innerHTML = `
                    <img src="${spriteUrl(fighterId, pose)}" onerror="this.style.opacity='0'" alt="${name}">
                    <div class="fighter-icon-label">${shortName}</div>
                `;
            }
        }
    }

    // ── Glow ──────────────────────────────────────────────
    // glowEnabled persisted in settings.prestigeGlowEnabled
    let _glowEnabled = !!(saveData.settings && saveData.settings.prestigeGlowEnabled);

    function setGlow(enabled) {
        _glowEnabled = enabled;
        saveData.settings.prestigeGlowEnabled = enabled;
        SaveManager.save(saveData);
        // Apply/remove glow on all fighter sprites currently rendered
        // Only glow the player sprite, not enemy or char-cards
        const playerEl = document.getElementById('playerSprite');
        if (playerEl) {
            if (enabled) playerEl.classList.add('glow-gold');
            else         playerEl.classList.remove('glow-gold');
        }
    }

    function isGlowEnabled() { return _glowEnabled; }

    // ── Hard Mode toggle UI ────────────────────────────────
    function refreshHardModeUI() {
        const row = document.getElementById('hardModeRow');
        if (!row) return;
        const unlocked = saveData.meta && saveData.meta.hardModeUnlocked;
        if (unlocked) row.classList.add('unlocked');
        else          row.classList.remove('unlocked');

        const toggle = document.getElementById('hardModeToggle');
        if (toggle) toggle.checked = saveData.settings.hardModeEnabled || false;
    }

    // ── Glow toggle UI ────────────────────────────────────
    function refreshGlowToggleUI() {
        const row = document.getElementById('glowToggleRow');
        if (!row) return;
        const unlocked = saveData.cosmetics && saveData.cosmetics.goldGlowUnlocked;
        if (unlocked) row.classList.add('unlocked');
        else          row.classList.remove('unlocked');

        const toggle = document.getElementById('glowToggle');
        if (toggle) toggle.checked = _glowEnabled;
    }

    // ── Unlock banner ─────────────────────────────────────
    function showUnlockBanner() {
        const banner = document.getElementById('unlockBanner');
        if (!banner) return;
        banner.textContent = '⭐  ARENA CLEARED  —  Hard Mode, Prestige Glow & Badge Unlocked  ⭐';
        banner.classList.add('visible');
        setTimeout(() => { banner.classList.remove('visible'); }, 6000);
    }

    // ── Wire all toggle events ─────────────────────────────
    function wireEvents() {
        // Hard mode checkbox
        const hmToggle = document.getElementById('hardModeToggle');
        if (hmToggle) {
            hmToggle.addEventListener('change', e => {
                // v16: ignore if a run is active — toggle is only valid on select/title screens
                if (hmToggle.disabled) return;
                saveData.settings.hardModeEnabled = e.target.checked;
                SaveManager.save(saveData);
                // Visual feedback label in HUD
                const pip = document.querySelector('#hardModeRow .hm-pip');
                if (pip) pip.textContent = e.target.checked ? 'ON' : 'NEW';
            });
        }

        // Glow checkbox
        const glowToggle = document.getElementById('glowToggle');
        if (glowToggle) {
            glowToggle.addEventListener('change', e => {
                setGlow(e.target.checked);
            });
        }
    }

    // ── Apply glow + v11 crimson aura to a newly rendered sprite ─────
    function applyGlowToEl(el) {
        // Only player sprite, never enemy
        if (!el || el.id !== 'playerSprite') return;
        // Normal clear: gold glow
        if (_glowEnabled) el.classList.add('glow-gold');
        // v11/v13 Hard clear: crimson aura (drop-shadow, no box)
        if (saveData.meta && saveData.meta.hardModeCleared) {
            el.classList.add('prestige-crimson-outline');
            // Periodic glitch flicker every 4–6s — fires once per rendered instance
            if (!el._crimsonGlitchTimer) {
                const scheduleGlitch = () => {
                    el._crimsonGlitchTimer = setTimeout(() => {
                        if (!el.isConnected) return; // sprite was re-rendered, stop
                        el.classList.add('glitch-tick');
                        el.addEventListener('animationend', () => {
                            el.classList.remove('glitch-tick');
                            el.classList.add('prestige-crimson-outline'); // re-add base aura
                        }, { once: true });
                        scheduleGlitch(); // reschedule
                    }, 4000 + Math.random() * 2000);
                };
                scheduleGlitch();
            }
        } else {
            el.classList.remove('prestige-crimson-outline');
        }
    }

    // ── v11: First Clash Spark Effect ─────────────────────
    function fireFirstClashSpark() {
        const playerEl = document.getElementById('playerSprite');
        if (!playerEl) return;

        // Ground flash element
        const flash = document.createElement('div');
        flash.className = 'prestige-spark-flash';
        playerEl.appendChild(flash);

        // Lightning bolt glyphs scattered under sprite
        const bolts = ['⚡', '⚡', '⚡'];
        bolts.forEach((sym, i) => {
            const bolt = document.createElement('div');
            bolt.className = 'prestige-spark-bolt';
            bolt.textContent = sym;
            bolt.style.left = `${20 + i * 30}%`;
            bolt.style.animationDelay = `${i * 0.04}s`;
            playerEl.appendChild(bolt);
            setTimeout(() => { try { bolt.remove(); } catch(e){} }, 350);
        });

        // Cleanup flash
        setTimeout(() => { try { flash.remove(); } catch(e){} }, 120);

        // Soft metallic sound cue — high-pass filtered noise burst
        try {
            const ctx = audioCtx;
            const t = ctx.currentTime;
            const bufLen = Math.floor(ctx.sampleRate * 0.06);
            const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < bufLen; i++) {
                d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.018)) * 0.45;
            }
            const src = ctx.createBufferSource(); src.buffer = buf;
            const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 3500;
            const g = ctx.createGain(); g.gain.setValueAtTime(0.35, t);
            src.connect(hp); hp.connect(g); g.connect(ctx.destination); src.start(t);
        } catch(e) {}
    }

    // ── Boot ──────────────────────────────────────────────
    function init() {
        refreshBadgeVisibility();
        refreshHardModeUI();
        refreshGlowToggleUI();
        wireEvents();
    }

    return {
        init,
        refreshBadgeVisibility,
        refreshHardModeUI,
        refreshGlowToggleUI,
        showUnlockBanner,
        setGlow,
        isGlowEnabled,
        applyGlowToEl,
        fireFirstClashSpark,     // v11
    };
})();

// Expose helpers used directly in gameOver / startFight
function refreshBadgeVisibility() { PrestigeSystem.refreshBadgeVisibility(); }
function showUnlockBanner()        { PrestigeSystem.showUnlockBanner(); }

// ============================================================
// INIT
// ============================================================
renderCharSelect();
PrestigeSystem.init();
ArenaFX.init();
// Enable arena FX if already unlocked from a previous run
if (saveData.arena && saveData.arena.upgradeUnlocked && saveData.arena.upgradeEnabled) {
    ArenaFX.enable(true);
}

// ============================================================
// TITLE SCREEN ENTRY
// ============================================================
window.enterGame = function() {
    // Flash the screen white briefly then transition
    const titleEl = document.getElementById('titleScreen');
    titleEl.style.transition = 'opacity 0.4s ease';
    titleEl.style.opacity = '0';
    setTimeout(() => {
        showScreen('selectScreen');
        // Make sure roster tab is active
        switchTab('roster');
    }, 400);
};

// ============================================================
// TAB SWITCHING
// ============================================================
// ============================================================
// RESET PROGRESS UI
// ============================================================
(function wireResetButton() {
    const resetBtn     = document.getElementById('resetProgressBtn');
    const confirmPanel = document.getElementById('resetConfirm');
    const confirmYes   = document.getElementById('resetConfirmYes');
    const confirmNo    = document.getElementById('resetConfirmNo');

    if (!resetBtn) return;

    resetBtn.addEventListener('click', () => {
        confirmPanel.style.display = 'block';
    });
    confirmNo.addEventListener('click', () => {
        confirmPanel.style.display = 'none';
    });
    confirmYes.addEventListener('click', () => {
        saveData = SaveManager.reset();
        confirmPanel.style.display = 'none';
        // Return to title
        showScreen('titleScreen');
        const titleEl = document.getElementById('titleScreen');
        if (titleEl) { titleEl.style.opacity = '1'; }
    });
})();

window.switchTab = function(tab) {
    // Refresh prestige UI whenever roster tab is shown
    if (tab === 'roster') {
        PrestigeSystem.refreshHardModeUI();
        PrestigeSystem.refreshGlowToggleUI();
        PrestigeSystem.refreshBadgeVisibility();
        ArenaFX.refreshToggleUI();
        renderCharSelect(); // refresh locked/unlocked state
    }
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.getAttribute('onclick').includes("'" + tab + "'")));
    document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
    const pane = document.getElementById(tab === 'roster' ? 'tabRoster' : 'tabHowtoplay');
    if (pane) pane.classList.add('active');
};

// ============================================================
// MAGNIFIER TOOLTIP
// ============================================================
(function() {
    const tooltip = document.getElementById('charTooltip');
    let activeCard = null;

    function showTooltip(card, fighter) {
        const arch = ARCHETYPES[fighter.archetype];

        document.getElementById('tooltipImg').src = spriteUrl(fighter.id, fighter.weapon);
        document.getElementById('tooltipImg').onerror = function() { this.style.display='none'; };
        document.getElementById('tooltipName').textContent = fighter.name;
        document.getElementById('tooltipArchetype').textContent = arch.name;
        document.getElementById('tooltipWeapon').textContent = '⚔ ' + fighter.weapon.toUpperCase();

        const statsEl = document.getElementById('tooltipStats');
        statsEl.innerHTML = [
            ['PWR', fighter.power],
            ['SPD', fighter.speed],
            ['GRD', fighter.guard],
            ['HP', fighter.baseHp],
        ].map(([label, val]) =>
            `<div class="tt-stat">${label}: <span>${val}</span></div>`
        ).join('');

        // HP pip bar
        const hpBar = document.getElementById('tooltipHpBar');
        hpBar.innerHTML = Array.from({length: fighter.baseHp}, () =>
            '<div class="tt-hp-pip"></div>'
        ).join('');

        document.getElementById('tooltipDesc').textContent = arch.desc;
        tooltip.classList.add('visible');
        positionTooltip(card);
    }

    function positionTooltip(card) {
        const rect = card.getBoundingClientRect();
        const appRect = document.querySelector('.app').getBoundingClientRect();
        const ttW = 260;
        const ttH = tooltip.offsetHeight || 380;

        let left = rect.right + 10;
        let top = rect.top;

        // Flip left if overflowing right of app
        if (left + ttW > appRect.right - 10) {
            left = rect.left - ttW - 10;
        }
        // Clamp top
        if (top + ttH > appRect.bottom - 10) {
            top = appRect.bottom - ttH - 10;
        }
        if (top < appRect.top + 10) top = appRect.top + 10;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
    }

    function hideTooltip() {
        tooltip.classList.remove('visible');
        activeCard = null;
    }

    // Delegate hover events on the char grid
    document.getElementById('charGrid').addEventListener('mouseover', function(e) {
        const card = e.target.closest('.char-card');
        if (!card || card === activeCard) return;
        activeCard = card;
        const id = parseInt(card.dataset.id);
        const fighter = ALL_FIGHTERS.find(f => f.id === id);
        if (fighter) showTooltip(card, fighter);
    });

    document.getElementById('charGrid').addEventListener('mouseleave', function() {
        hideTooltip();
    });
})();

// ============================================================
// v18: MOBILE ENHANCEMENTS
// Touch-first controls, sticky combat bar, collapsible log,
// mobile fighter info panel. Game logic completely unchanged.
// ============================================================
(function() {
    'use strict';

    const isMobile = () => window.innerWidth <= 480 || window.innerHeight <= 480;

    // ── Collapsible details drawer ───────────────────────────
    window.toggleDetails = function() {
        const log = document.getElementById('clashLog');
        const btn = document.getElementById('detailsToggle');
        const open = log.classList.toggle('open');
        btn.classList.toggle('open', open);
        if (open) log.scrollTop = log.scrollHeight;
    };

    // Auto-open on new log entries so the player sees results
    const origLog = window.addLog;
    // Wrap the log scroll to also update mobile bar
    const clashLogEl = document.getElementById('clashLog');
    if (clashLogEl) {
        const logObserver = new MutationObserver(() => {
            if (isMobile() && clashLogEl.classList.contains('open')) {
                clashLogEl.scrollTop = clashLogEl.scrollHeight;
            }
        });
        logObserver.observe(clashLogEl, { childList: true });
    }

    // ── Mobile sticky combat bar ─────────────────────────────
    function mcbPips(current, max, type) {
        let s = '';
        for (let i = 0; i < max; i++) {
            const empty = i >= current ? ' empty' : '';
            s += `<div class="mcb-pip ${type}${empty}"></div>`;
        }
        return s;
    }
    function mcbStabPips(val) {
        let s = '';
        for (let i = 0; i < 5; i++) {
            s += `<div class="mcb-pip stab${i >= val ? ' empty' : ''}"></div>`;
        }
        return s;
    }

    function updateMobileCombatBar() {
        if (!isMobile()) return;
        if (typeof run === 'undefined' || !run.player || !run.currentEnemy) return;

        const p = run.player, e = run.currentEnemy;
        document.getElementById('mcbPlayerName').textContent = p.name;
        document.getElementById('mcbEnemyName').textContent  = e.name;
        document.getElementById('mcbPlayerHp').innerHTML  = mcbPips(p.hp, p.maxHp, '');
        document.getElementById('mcbEnemyHp').innerHTML   = mcbPips(e.hp, e.maxHp, 'enemy');
        document.getElementById('mcbPlayerStab').innerHTML = mcbStabPips(p.stability);
        document.getElementById('mcbEnemyStab').innerHTML  = mcbStabPips(e.stability);
        document.getElementById('mcbFight').textContent   = 'F' + (run.wins + 1);
        document.getElementById('mcbClash').textContent   = run.clashNum > 0 ? 'Clash ' + run.clashNum : '';
    }

    // Patch renderArena to also update mobile bar (non-invasive)
    const origRenderArena = window.renderArena;
    if (typeof origRenderArena === 'function') {
        window.renderArena = function() {
            origRenderArena.apply(this, arguments);
            updateMobileCombatBar();
        };
    }

    // Also update after each clash resolves
    const origShowScreen = window.showScreen;
    if (typeof origShowScreen === 'function') {
        window.showScreen = function(screenId) {
            origShowScreen.apply(this, arguments);
            // Hide mobile combat bar when not in arena
            const bar = document.getElementById('mobileCombatBar');
            if (bar) bar.style.display = (screenId === 'arenaScreen' && isMobile()) ? 'block' : 'none';
        };
    }

    // ── Mobile fighter info panel ────────────────────────────
    let mfpFighterId = null;

    function showMobileFighterPanel(fighter) {
        mfpFighterId = fighter.id;
        const arch = ARCHETYPES[fighter.archetype];

        document.getElementById('mfpImg').src = spriteUrl(fighter.id, fighter.weapon);
        document.getElementById('mfpImg').onerror = function() { this.style.display='none'; };
        document.getElementById('mfpName').textContent = fighter.name;
        document.getElementById('mfpArch').textContent = arch.name;
        document.getElementById('mfpWeapon').textContent = '⚔ ' + fighter.weapon.toUpperCase();

        document.getElementById('mfpStats').innerHTML = [
            ['PWR', fighter.power],
            ['SPD', fighter.speed],
            ['GRD', fighter.guard],
            ['HP',  fighter.baseHp],
        ].map(([l, v]) => `<div class="mfp-stat">${l}: <span>${v}</span></div>`).join('');

        document.getElementById('mfpHpBar').innerHTML =
            Array.from({length: fighter.baseHp}, () => '<div class="mfp-hp-pip"></div>').join('');

        document.getElementById('mfpDesc').textContent = arch.desc;

        // Reflect locked state on select button
        const isLocked = !saveData.meta.unlockedCharacters.includes(fighter.id) && fighter._locked;
        const btn = document.getElementById('mfpSelectBtn');
        btn.disabled = isLocked;
        btn.textContent = isLocked ? 'LOCKED' : 'SELECT THIS FIGHTER';

        document.getElementById('mobileFighterPanel').classList.add('visible');
    }

    function hideMobileFighterPanel() {
        document.getElementById('mobileFighterPanel').classList.remove('visible');
        mfpFighterId = null;
    }

    // Close button
    document.getElementById('mfpClose').addEventListener('click', hideMobileFighterPanel);

    // Close on backdrop tap
    document.getElementById('mobileFighterPanel').addEventListener('click', function(e) {
        if (e.target === this) hideMobileFighterPanel();
    });

    // Select fighter from panel — call selectFighter directly (no card.click())
    document.getElementById('mfpSelectBtn').addEventListener('click', function() {
        if (!mfpFighterId) return;
        const fighter = ALL_FIGHTERS.find(f => f.id === mfpFighterId);
        if (fighter && !fighter._locked) {
            selectFighter(mfpFighterId);
        }
        hideMobileFighterPanel();
    });

    // ── Touch event on char grid → show panel AND select fighter ──
    // No preventDefault — let the native click also fire so selectFighter
    // is called both by touch and by the panel's SELECT button path.
    document.getElementById('charGrid').addEventListener('touchend', function(e) {
        if (!isMobile()) return;
        const card = e.target.closest('.char-card');
        if (!card) return;
        const id = parseInt(card.dataset.id);
        const fighter = ALL_FIGHTERS.find(f => f.id === id);
        if (!fighter) return;
        // Select the fighter immediately so startRunBtn is enabled
        if (!card.classList.contains('locked-card')) {
            selectFighter(id);
        }
        // Show panel as a preview/confirmation
        showMobileFighterPanel(fighter);
    }, { passive: true });

    // ── Title screen: "CLICK TO PLAY" → "TAP TO PLAY" on mobile
    function updateTitleCta() {
        const cta = document.querySelector('.title-cta');
        if (cta && isMobile()) {
            cta.textContent = '— TAP TO PLAY —';
        }
    }
    updateTitleCta();
    window.addEventListener('resize', updateTitleCta);

    // ── Upgrade cards: ensure tap works fine ─────────────────
    // (upgrade cards already have click listeners from JS; touch → click works natively)
    // Add active state feedback for upgrade cards already rendered dynamically
    document.addEventListener('touchstart', function(e) {
        const card = e.target.closest('.upgrade-card');
        if (card) card.classList.add('tapped');
    }, { passive: true });
    document.addEventListener('touchend', function(e) {
        document.querySelectorAll('.upgrade-card.tapped').forEach(c => c.classList.remove('tapped'));
    }, { passive: true });

    // ── Viewport resize: recalculate mobile bar visibility ───
    window.addEventListener('resize', function() {
        const bar = document.getElementById('mobileCombatBar');
        if (bar) {
            const arenaActive = document.getElementById('arenaScreen')?.classList.contains('active');
            bar.style.display = (isMobile() && arenaActive) ? 'block' : 'none';
        }
    });

})();

</script>
</body>
</html>
